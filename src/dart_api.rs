/* automatically generated by rust-bindgen 0.71.1 */

// Automatically generated by bindgen. Do not edit.
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(unused)]

pub const __has_safe_buffers: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PRI_8_LENGTH_MODIFIER__: &[u8; 3] = b"hh\0";
pub const __PRI_64_LENGTH_MODIFIER__: &[u8; 3] = b"ll\0";
pub const __SCN_64_LENGTH_MODIFIER__: &[u8; 3] = b"ll\0";
pub const __PRI_MAX_LENGTH_MODIFIER__: &[u8; 2] = b"j\0";
pub const __SCN_MAX_LENGTH_MODIFIER__: &[u8; 2] = b"j\0";
pub const PRId8: &[u8; 4] = b"hhd\0";
pub const PRIi8: &[u8; 4] = b"hhi\0";
pub const PRIo8: &[u8; 4] = b"hho\0";
pub const PRIu8: &[u8; 4] = b"hhu\0";
pub const PRIx8: &[u8; 4] = b"hhx\0";
pub const PRIX8: &[u8; 4] = b"hhX\0";
pub const PRId16: &[u8; 3] = b"hd\0";
pub const PRIi16: &[u8; 3] = b"hi\0";
pub const PRIo16: &[u8; 3] = b"ho\0";
pub const PRIu16: &[u8; 3] = b"hu\0";
pub const PRIx16: &[u8; 3] = b"hx\0";
pub const PRIX16: &[u8; 3] = b"hX\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRId64: &[u8; 4] = b"lld\0";
pub const PRIi64: &[u8; 4] = b"lli\0";
pub const PRIo64: &[u8; 4] = b"llo\0";
pub const PRIu64: &[u8; 4] = b"llu\0";
pub const PRIx64: &[u8; 4] = b"llx\0";
pub const PRIX64: &[u8; 4] = b"llX\0";
pub const PRIdLEAST8: &[u8; 4] = b"hhd\0";
pub const PRIiLEAST8: &[u8; 4] = b"hhi\0";
pub const PRIoLEAST8: &[u8; 4] = b"hho\0";
pub const PRIuLEAST8: &[u8; 4] = b"hhu\0";
pub const PRIxLEAST8: &[u8; 4] = b"hhx\0";
pub const PRIXLEAST8: &[u8; 4] = b"hhX\0";
pub const PRIdLEAST16: &[u8; 3] = b"hd\0";
pub const PRIiLEAST16: &[u8; 3] = b"hi\0";
pub const PRIoLEAST16: &[u8; 3] = b"ho\0";
pub const PRIuLEAST16: &[u8; 3] = b"hu\0";
pub const PRIxLEAST16: &[u8; 3] = b"hx\0";
pub const PRIXLEAST16: &[u8; 3] = b"hX\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIdLEAST64: &[u8; 4] = b"lld\0";
pub const PRIiLEAST64: &[u8; 4] = b"lli\0";
pub const PRIoLEAST64: &[u8; 4] = b"llo\0";
pub const PRIuLEAST64: &[u8; 4] = b"llu\0";
pub const PRIxLEAST64: &[u8; 4] = b"llx\0";
pub const PRIXLEAST64: &[u8; 4] = b"llX\0";
pub const PRIdFAST8: &[u8; 4] = b"hhd\0";
pub const PRIiFAST8: &[u8; 4] = b"hhi\0";
pub const PRIoFAST8: &[u8; 4] = b"hho\0";
pub const PRIuFAST8: &[u8; 4] = b"hhu\0";
pub const PRIxFAST8: &[u8; 4] = b"hhx\0";
pub const PRIXFAST8: &[u8; 4] = b"hhX\0";
pub const PRIdFAST16: &[u8; 3] = b"hd\0";
pub const PRIiFAST16: &[u8; 3] = b"hi\0";
pub const PRIoFAST16: &[u8; 3] = b"ho\0";
pub const PRIuFAST16: &[u8; 3] = b"hu\0";
pub const PRIxFAST16: &[u8; 3] = b"hx\0";
pub const PRIXFAST16: &[u8; 3] = b"hX\0";
pub const PRIdFAST32: &[u8; 2] = b"d\0";
pub const PRIiFAST32: &[u8; 2] = b"i\0";
pub const PRIoFAST32: &[u8; 2] = b"o\0";
pub const PRIuFAST32: &[u8; 2] = b"u\0";
pub const PRIxFAST32: &[u8; 2] = b"x\0";
pub const PRIXFAST32: &[u8; 2] = b"X\0";
pub const PRIdFAST64: &[u8; 4] = b"lld\0";
pub const PRIiFAST64: &[u8; 4] = b"lli\0";
pub const PRIoFAST64: &[u8; 4] = b"llo\0";
pub const PRIuFAST64: &[u8; 4] = b"llu\0";
pub const PRIxFAST64: &[u8; 4] = b"llx\0";
pub const PRIXFAST64: &[u8; 4] = b"llX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"jd\0";
pub const PRIiMAX: &[u8; 3] = b"ji\0";
pub const PRIoMAX: &[u8; 3] = b"jo\0";
pub const PRIuMAX: &[u8; 3] = b"ju\0";
pub const PRIxMAX: &[u8; 3] = b"jx\0";
pub const PRIXMAX: &[u8; 3] = b"jX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNd64: &[u8; 4] = b"lld\0";
pub const SCNi64: &[u8; 4] = b"lli\0";
pub const SCNo64: &[u8; 4] = b"llo\0";
pub const SCNu64: &[u8; 4] = b"llu\0";
pub const SCNx64: &[u8; 4] = b"llx\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNdLEAST64: &[u8; 4] = b"lld\0";
pub const SCNiLEAST64: &[u8; 4] = b"lli\0";
pub const SCNoLEAST64: &[u8; 4] = b"llo\0";
pub const SCNuLEAST64: &[u8; 4] = b"llu\0";
pub const SCNxLEAST64: &[u8; 4] = b"llx\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNdFAST16: &[u8; 3] = b"hd\0";
pub const SCNiFAST16: &[u8; 3] = b"hi\0";
pub const SCNoFAST16: &[u8; 3] = b"ho\0";
pub const SCNuFAST16: &[u8; 3] = b"hu\0";
pub const SCNxFAST16: &[u8; 3] = b"hx\0";
pub const SCNdFAST32: &[u8; 2] = b"d\0";
pub const SCNiFAST32: &[u8; 2] = b"i\0";
pub const SCNoFAST32: &[u8; 2] = b"o\0";
pub const SCNuFAST32: &[u8; 2] = b"u\0";
pub const SCNxFAST32: &[u8; 2] = b"x\0";
pub const SCNdFAST64: &[u8; 4] = b"lld\0";
pub const SCNiFAST64: &[u8; 4] = b"lli\0";
pub const SCNoFAST64: &[u8; 4] = b"llo\0";
pub const SCNuFAST64: &[u8; 4] = b"llu\0";
pub const SCNxFAST64: &[u8; 4] = b"llx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"jd\0";
pub const SCNiMAX: &[u8; 3] = b"ji\0";
pub const SCNoMAX: &[u8; 3] = b"jo\0";
pub const SCNuMAX: &[u8; 3] = b"ju\0";
pub const SCNxMAX: &[u8; 3] = b"jx\0";
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOS: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_5: u32 = 101405;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_12_4: u32 = 120400;
pub const __MAC_12_5: u32 = 120500;
pub const __MAC_12_6: u32 = 120600;
pub const __MAC_12_7: u32 = 120700;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __MAC_13_4: u32 = 130400;
pub const __MAC_13_5: u32 = 130500;
pub const __MAC_13_6: u32 = 130600;
pub const __MAC_14_0: u32 = 140000;
pub const __MAC_14_1: u32 = 140100;
pub const __MAC_14_2: u32 = 140200;
pub const __MAC_14_3: u32 = 140300;
pub const __MAC_14_4: u32 = 140400;
pub const __MAC_14_5: u32 = 140500;
pub const __MAC_15_0: u32 = 150000;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_4: u32 = 140400;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_15_5: u32 = 150500;
pub const __IPHONE_15_6: u32 = 150600;
pub const __IPHONE_15_7: u32 = 150700;
pub const __IPHONE_15_8: u32 = 150800;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __IPHONE_16_5: u32 = 160500;
pub const __IPHONE_16_6: u32 = 160600;
pub const __IPHONE_16_7: u32 = 160700;
pub const __IPHONE_17_0: u32 = 170000;
pub const __IPHONE_17_1: u32 = 170100;
pub const __IPHONE_17_2: u32 = 170200;
pub const __IPHONE_17_3: u32 = 170300;
pub const __IPHONE_17_4: u32 = 170400;
pub const __IPHONE_17_5: u32 = 170500;
pub const __IPHONE_18_0: u32 = 180000;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_8_6: u32 = 80600;
pub const __WATCHOS_8_7: u32 = 80700;
pub const __WATCHOS_8_8: u32 = 80800;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const __WATCHOS_9_5: u32 = 90500;
pub const __WATCHOS_9_6: u32 = 90600;
pub const __WATCHOS_10_0: u32 = 100000;
pub const __WATCHOS_10_1: u32 = 100100;
pub const __WATCHOS_10_2: u32 = 100200;
pub const __WATCHOS_10_3: u32 = 100300;
pub const __WATCHOS_10_4: u32 = 100400;
pub const __WATCHOS_10_5: u32 = 100500;
pub const __WATCHOS_11_0: u32 = 110000;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_15_5: u32 = 150500;
pub const __TVOS_15_6: u32 = 150600;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __TVOS_16_5: u32 = 160500;
pub const __TVOS_16_6: u32 = 160600;
pub const __TVOS_17_0: u32 = 170000;
pub const __TVOS_17_1: u32 = 170100;
pub const __TVOS_17_2: u32 = 170200;
pub const __TVOS_17_3: u32 = 170300;
pub const __TVOS_17_4: u32 = 170400;
pub const __TVOS_17_5: u32 = 170500;
pub const __TVOS_18_0: u32 = 180000;
pub const __BRIDGEOS_2_0: u32 = 20000;
pub const __BRIDGEOS_3_0: u32 = 30000;
pub const __BRIDGEOS_3_1: u32 = 30100;
pub const __BRIDGEOS_3_4: u32 = 30400;
pub const __BRIDGEOS_4_0: u32 = 40000;
pub const __BRIDGEOS_4_1: u32 = 40100;
pub const __BRIDGEOS_5_0: u32 = 50000;
pub const __BRIDGEOS_5_1: u32 = 50100;
pub const __BRIDGEOS_5_3: u32 = 50300;
pub const __BRIDGEOS_6_0: u32 = 60000;
pub const __BRIDGEOS_6_2: u32 = 60200;
pub const __BRIDGEOS_6_4: u32 = 60400;
pub const __BRIDGEOS_6_5: u32 = 60500;
pub const __BRIDGEOS_6_6: u32 = 60600;
pub const __BRIDGEOS_7_0: u32 = 70000;
pub const __BRIDGEOS_7_1: u32 = 70100;
pub const __BRIDGEOS_7_2: u32 = 70200;
pub const __BRIDGEOS_7_3: u32 = 70300;
pub const __BRIDGEOS_7_4: u32 = 70400;
pub const __BRIDGEOS_7_6: u32 = 70600;
pub const __BRIDGEOS_8_0: u32 = 80000;
pub const __BRIDGEOS_8_1: u32 = 80100;
pub const __BRIDGEOS_8_2: u32 = 80200;
pub const __BRIDGEOS_8_3: u32 = 80300;
pub const __BRIDGEOS_8_4: u32 = 80400;
pub const __BRIDGEOS_8_5: u32 = 80500;
pub const __BRIDGEOS_9_0: u32 = 90000;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __DRIVERKIT_22_0: u32 = 220000;
pub const __DRIVERKIT_22_4: u32 = 220400;
pub const __DRIVERKIT_22_5: u32 = 220500;
pub const __DRIVERKIT_22_6: u32 = 220600;
pub const __DRIVERKIT_23_0: u32 = 230000;
pub const __DRIVERKIT_23_1: u32 = 230100;
pub const __DRIVERKIT_23_2: u32 = 230200;
pub const __DRIVERKIT_23_3: u32 = 230300;
pub const __DRIVERKIT_23_4: u32 = 230400;
pub const __DRIVERKIT_23_5: u32 = 230500;
pub const __DRIVERKIT_24_0: u32 = 240000;
pub const __VISIONOS_1_0: u32 = 10000;
pub const __VISIONOS_1_1: u32 = 10100;
pub const __VISIONOS_1_2: u32 = 10200;
pub const __VISIONOS_2_0: u32 = 20000;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_5: u32 = 101405;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_15_4: u32 = 101504;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_11_1: u32 = 110100;
pub const MAC_OS_VERSION_11_3: u32 = 110300;
pub const MAC_OS_VERSION_11_4: u32 = 110400;
pub const MAC_OS_VERSION_11_5: u32 = 110500;
pub const MAC_OS_VERSION_11_6: u32 = 110600;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_12_1: u32 = 120100;
pub const MAC_OS_VERSION_12_2: u32 = 120200;
pub const MAC_OS_VERSION_12_3: u32 = 120300;
pub const MAC_OS_VERSION_12_4: u32 = 120400;
pub const MAC_OS_VERSION_12_5: u32 = 120500;
pub const MAC_OS_VERSION_12_6: u32 = 120600;
pub const MAC_OS_VERSION_12_7: u32 = 120700;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const MAC_OS_VERSION_13_1: u32 = 130100;
pub const MAC_OS_VERSION_13_2: u32 = 130200;
pub const MAC_OS_VERSION_13_3: u32 = 130300;
pub const MAC_OS_VERSION_13_4: u32 = 130400;
pub const MAC_OS_VERSION_13_5: u32 = 130500;
pub const MAC_OS_VERSION_13_6: u32 = 130600;
pub const MAC_OS_VERSION_14_0: u32 = 140000;
pub const MAC_OS_VERSION_14_1: u32 = 140100;
pub const MAC_OS_VERSION_14_2: u32 = 140200;
pub const MAC_OS_VERSION_14_3: u32 = 140300;
pub const MAC_OS_VERSION_14_4: u32 = 140400;
pub const MAC_OS_VERSION_14_5: u32 = 140500;
pub const MAC_OS_VERSION_15_0: u32 = 150000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 150000;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const USE_CLANG_TYPES: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const USE_CLANG_STDDEF: u32 = 0;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const DART_FLAGS_CURRENT_VERSION: u32 = 12;
pub const DART_INITIALIZE_PARAMS_CURRENT_VERSION: u32 = 4;
pub const DART_KERNEL_ISOLATE_NAME: &[u8; 15] = b"kernel-service\0";
pub const DART_VM_SERVICE_ISOLATE_NAME: &[u8; 11] = b"vm-service\0";
pub const kSnapshotBuildIdCSymbol: &[u8; 21] = b"kDartSnapshotBuildId\0";
pub const kVmSnapshotDataCSymbol: &[u8; 20] = b"kDartVmSnapshotData\0";
pub const kVmSnapshotInstructionsCSymbol: &[u8; 28] = b"kDartVmSnapshotInstructions\0";
pub const kVmSnapshotBssCSymbol: &[u8; 19] = b"kDartVmSnapshotBss\0";
pub const kIsolateSnapshotDataCSymbol: &[u8; 25] = b"kDartIsolateSnapshotData\0";
pub const kIsolateSnapshotInstructionsCSymbol: &[u8; 33] = b"kDartIsolateSnapshotInstructions\0";
pub const kIsolateSnapshotBssCSymbol: &[u8; 24] = b"kDartIsolateSnapshotBss\0";
pub const kSnapshotBuildIdAsmSymbol: &[u8; 22] = b"_kDartSnapshotBuildId\0";
pub const kVmSnapshotDataAsmSymbol: &[u8; 21] = b"_kDartVmSnapshotData\0";
pub const kVmSnapshotInstructionsAsmSymbol: &[u8; 29] = b"_kDartVmSnapshotInstructions\0";
pub const kVmSnapshotBssAsmSymbol: &[u8; 20] = b"_kDartVmSnapshotBss\0";
pub const kIsolateSnapshotDataAsmSymbol: &[u8; 26] = b"_kDartIsolateSnapshotData\0";
pub const kIsolateSnapshotInstructionsAsmSymbol: &[u8; 34] = b"_kDartIsolateSnapshotInstructions\0";
pub const kIsolateSnapshotBssAsmSymbol: &[u8; 25] = b"_kDartIsolateSnapshotBss\0";
unsafe extern "C" {
    pub fn __assert_rtn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> !;
}
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t"][::std::mem::size_of::<__mbstate_t>() - 128usize];
    ["Alignment of __mbstate_t"][::std::mem::align_of::<__mbstate_t>() - 8usize];
    ["Offset of field: __mbstate_t::__mbstate8"]
        [::std::mem::offset_of!(__mbstate_t, __mbstate8) - 0usize];
    ["Offset of field: __mbstate_t::_mbstateL"]
        [::std::mem::offset_of!(__mbstate_t, _mbstateL) - 0usize];
};
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_pthread_handler_rec"]
        [::std::mem::size_of::<__darwin_pthread_handler_rec>() - 24usize];
    ["Alignment of __darwin_pthread_handler_rec"]
        [::std::mem::align_of::<__darwin_pthread_handler_rec>() - 8usize];
    ["Offset of field: __darwin_pthread_handler_rec::__routine"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __routine) - 0usize];
    ["Offset of field: __darwin_pthread_handler_rec::__arg"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __arg) - 8usize];
    ["Offset of field: __darwin_pthread_handler_rec::__next"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __next) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_attr_t"][::std::mem::size_of::<_opaque_pthread_attr_t>() - 64usize];
    ["Alignment of _opaque_pthread_attr_t"]
        [::std::mem::align_of::<_opaque_pthread_attr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_attr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_attr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_attr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_attr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_cond_t"][::std::mem::size_of::<_opaque_pthread_cond_t>() - 48usize];
    ["Alignment of _opaque_pthread_cond_t"]
        [::std::mem::align_of::<_opaque_pthread_cond_t>() - 8usize];
    ["Offset of field: _opaque_pthread_cond_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_cond_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_cond_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_cond_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_condattr_t"]
        [::std::mem::size_of::<_opaque_pthread_condattr_t>() - 16usize];
    ["Alignment of _opaque_pthread_condattr_t"]
        [::std::mem::align_of::<_opaque_pthread_condattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_condattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_condattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_condattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_condattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_mutex_t"][::std::mem::size_of::<_opaque_pthread_mutex_t>() - 64usize];
    ["Alignment of _opaque_pthread_mutex_t"]
        [::std::mem::align_of::<_opaque_pthread_mutex_t>() - 8usize];
    ["Offset of field: _opaque_pthread_mutex_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_mutex_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_mutex_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_mutex_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_mutexattr_t"]
        [::std::mem::size_of::<_opaque_pthread_mutexattr_t>() - 16usize];
    ["Alignment of _opaque_pthread_mutexattr_t"]
        [::std::mem::align_of::<_opaque_pthread_mutexattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_mutexattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_mutexattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_mutexattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_mutexattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_once_t"][::std::mem::size_of::<_opaque_pthread_once_t>() - 16usize];
    ["Alignment of _opaque_pthread_once_t"]
        [::std::mem::align_of::<_opaque_pthread_once_t>() - 8usize];
    ["Offset of field: _opaque_pthread_once_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_once_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_once_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_once_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_rwlock_t"]
        [::std::mem::size_of::<_opaque_pthread_rwlock_t>() - 200usize];
    ["Alignment of _opaque_pthread_rwlock_t"]
        [::std::mem::align_of::<_opaque_pthread_rwlock_t>() - 8usize];
    ["Offset of field: _opaque_pthread_rwlock_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_rwlock_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_rwlock_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_rwlock_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_rwlockattr_t"]
        [::std::mem::size_of::<_opaque_pthread_rwlockattr_t>() - 24usize];
    ["Alignment of _opaque_pthread_rwlockattr_t"]
        [::std::mem::align_of::<_opaque_pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_rwlockattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_rwlockattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_rwlockattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_rwlockattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_t"][::std::mem::size_of::<_opaque_pthread_t>() - 8192usize];
    ["Alignment of _opaque_pthread_t"][::std::mem::align_of::<_opaque_pthread_t>() - 8usize];
    ["Offset of field: _opaque_pthread_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_t::__cleanup_stack"]
        [::std::mem::offset_of!(_opaque_pthread_t, __cleanup_stack) - 8usize];
    ["Offset of field: _opaque_pthread_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_t, __opaque) - 16usize];
};
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type wchar_t = __darwin_wchar_t;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
unsafe extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of imaxdiv_t"][::std::mem::size_of::<imaxdiv_t>() - 16usize];
    ["Alignment of imaxdiv_t"][::std::mem::align_of::<imaxdiv_t>() - 8usize];
    ["Offset of field: imaxdiv_t::quot"][::std::mem::offset_of!(imaxdiv_t, quot) - 0usize];
    ["Offset of field: imaxdiv_t::rem"][::std::mem::offset_of!(imaxdiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
unsafe extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
unsafe extern "C" {
    pub fn wcstoimax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn wcstoumax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_Isolate {
    _unused: [u8; 0],
}
#[doc = " An isolate is the unit of concurrency in Dart. Each isolate has\n its own memory and thread of control. No state is shared between\n isolates. Instead, isolates communicate by message passing.\n\n Each thread keeps track of its current isolate, which is the\n isolate which is ready to execute on the current thread. The\n current isolate may be NULL, in which case no isolate is ready to\n execute. Most of the Dart apis require there to be a current\n isolate in order to function without error. The current isolate is\n set by any call to Dart_CreateIsolateGroup or Dart_EnterIsolate."]
pub type Dart_Isolate = *mut _Dart_Isolate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_IsolateGroup {
    _unused: [u8; 0],
}
pub type Dart_IsolateGroup = *mut _Dart_IsolateGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_Handle {
    _unused: [u8; 0],
}
#[doc = " An object reference managed by the Dart VM garbage collector.\n\n Because the garbage collector may move objects, it is unsafe to\n refer to objects directly. Instead, we refer to objects through\n handles, which are known to the garbage collector and updated\n automatically when the object is moved. Handles should be passed\n by value (except in cases like out-parameters) and should never be\n allocated on the heap.\n\n Most functions in the Dart Embedding API return a handle. When a\n function completes normally, this will be a valid handle to an\n object in the Dart VM heap. This handle may represent the result of\n the operation or it may be a special valid handle used merely to\n indicate successful completion. Note that a valid handle may in\n some cases refer to the null object.\n\n --- Error handles ---\n\n When a function encounters a problem that prevents it from\n completing normally, it returns an error handle (See Dart_IsError).\n An error handle has an associated error message that gives more\n details about the problem (See Dart_GetError).\n\n There are four kinds of error handles that can be produced,\n depending on what goes wrong:\n\n - Api error handles are produced when an api function is misused.\n   This happens when a Dart embedding api function is called with\n   invalid arguments or in an invalid context.\n\n - Unhandled exception error handles are produced when, during the\n   execution of Dart code, an exception is thrown but not caught.\n   Prototypically this would occur during a call to Dart_Invoke, but\n   it can occur in any function which triggers the execution of Dart\n   code (for example, Dart_ToString).\n\n   An unhandled exception error provides access to an exception and\n   stacktrace via the functions Dart_ErrorGetException and\n   Dart_ErrorGetStackTrace.\n\n - Compilation error handles are produced when, during the execution\n   of Dart code, a compile-time error occurs.  As above, this can\n   occur in any function which triggers the execution of Dart code.\n\n - Fatal error handles are produced when the system wants to shut\n   down the current isolate.\n\n --- Propagating errors ---\n\n When an error handle is returned from the top level invocation of\n Dart code in a program, the embedder must handle the error as they\n see fit.  Often, the embedder will print the error message produced\n by Dart_Error and exit the program.\n\n When an error is returned while in the body of a native function,\n it can be propagated up the call stack by calling\n Dart_PropagateError, Dart_SetReturnValue, or Dart_ThrowException.\n Errors should be propagated unless there is a specific reason not\n to.  If an error is not propagated then it is ignored.  For\n example, if an unhandled exception error is ignored, that\n effectively \"catches\" the unhandled exception.  Fatal errors must\n always be propagated.\n\n When an error is propagated, any current scopes created by\n Dart_EnterScope will be exited.\n\n Using Dart_SetReturnValue to propagate an exception is somewhat\n more convenient than using Dart_PropagateError, and should be\n preferred for reasons discussed below.\n\n Dart_PropagateError and Dart_ThrowException do not return.  Instead\n they transfer control non-locally using a setjmp-like mechanism.\n This can be inconvenient if you have resources that you need to\n clean up before propagating the error.\n\n When relying on Dart_PropagateError, we often return error handles\n rather than propagating them from helper functions.  Consider the\n following contrived example:\n\n 1    Dart_Handle isLongStringHelper(Dart_Handle arg) {\n 2      intptr_t* length = 0;\n 3      result = Dart_StringLength(arg, &length);\n 4      if (Dart_IsError(result)) {\n 5        return result;\n 6      }\n 7      return Dart_NewBoolean(length > 100);\n 8    }\n 9\n 10   void NativeFunction_isLongString(Dart_NativeArguments args) {\n 11     Dart_EnterScope();\n 12     AllocateMyResource();\n 13     Dart_Handle arg = Dart_GetNativeArgument(args, 0);\n 14     Dart_Handle result = isLongStringHelper(arg);\n 15     if (Dart_IsError(result)) {\n 16       FreeMyResource();\n 17       Dart_PropagateError(result);\n 18       abort();  // will not reach here\n 19     }\n 20     Dart_SetReturnValue(result);\n 21     FreeMyResource();\n 22     Dart_ExitScope();\n 23   }\n\n In this example, we have a native function which calls a helper\n function to do its work.  On line 5, the helper function could call\n Dart_PropagateError, but that would not give the native function a\n chance to call FreeMyResource(), causing a leak.  Instead, the\n helper function returns the error handle to the caller, giving the\n caller a chance to clean up before propagating the error handle.\n\n When an error is propagated by calling Dart_SetReturnValue, the\n native function will be allowed to complete normally and then the\n exception will be propagated only once the native call\n returns. This can be convenient, as it allows the C code to clean\n up normally.\n\n The example can be written more simply using Dart_SetReturnValue to\n propagate the error.\n\n 1    Dart_Handle isLongStringHelper(Dart_Handle arg) {\n 2      intptr_t* length = 0;\n 3      result = Dart_StringLength(arg, &length);\n 4      if (Dart_IsError(result)) {\n 5        return result\n 6      }\n 7      return Dart_NewBoolean(length > 100);\n 8    }\n 9\n 10   void NativeFunction_isLongString(Dart_NativeArguments args) {\n 11     Dart_EnterScope();\n 12     AllocateMyResource();\n 13     Dart_Handle arg = Dart_GetNativeArgument(args, 0);\n 14     Dart_SetReturnValue(isLongStringHelper(arg));\n 15     FreeMyResource();\n 16     Dart_ExitScope();\n 17   }\n\n In this example, the call to Dart_SetReturnValue on line 14 will\n either return the normal return value or the error (potentially\n generated on line 3).  The call to FreeMyResource on line 15 will\n execute in either case.\n\n --- Local and persistent handles ---\n\n Local handles are allocated within the current scope (see\n Dart_EnterScope) and go away when the current scope exits. Unless\n otherwise indicated, callers should assume that all functions in\n the Dart embedding api return local handles.\n\n Persistent handles are allocated within the current isolate. They\n can be used to store objects across scopes. Persistent handles have\n the lifetime of the current isolate unless they are explicitly\n deallocated (see Dart_DeletePersistentHandle).\n The type Dart_Handle represents a handle (both local and persistent).\n The type Dart_PersistentHandle is a Dart_Handle and it is used to\n document that a persistent handle is expected as a parameter to a call\n or the return value from a call is a persistent handle.\n\n FinalizableHandles are persistent handles which are auto deleted when\n the object is garbage collected. It is never safe to use these handles\n unless you know the object is still reachable.\n\n WeakPersistentHandles are persistent handles which are automatically set\n to point Dart_Null when the object is garbage collected. They are not auto\n deleted, so it is safe to use them after the object has become unreachable."]
pub type Dart_Handle = *mut _Dart_Handle;
pub type Dart_PersistentHandle = Dart_Handle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_WeakPersistentHandle {
    _unused: [u8; 0],
}
pub type Dart_WeakPersistentHandle = *mut _Dart_WeakPersistentHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_FinalizableHandle {
    _unused: [u8; 0],
}
pub type Dart_FinalizableHandle = *mut _Dart_FinalizableHandle;
pub type Dart_HandleFinalizer = ::std::option::Option<
    unsafe extern "C" fn(
        isolate_callback_data: *mut ::std::os::raw::c_void,
        peer: *mut ::std::os::raw::c_void,
    ),
>;
unsafe extern "C" {
    #[doc = " Is this an error handle?\n\n Requires there to be a current isolate."]
    pub fn Dart_IsError(handle: Dart_Handle) -> bool;
}
unsafe extern "C" {
    #[doc = " Is this an api error handle?\n\n Api error handles are produced when an api function is misused.\n This happens when a Dart embedding api function is called with\n invalid arguments or in an invalid context.\n\n Requires there to be a current isolate."]
    pub fn Dart_IsApiError(handle: Dart_Handle) -> bool;
}
unsafe extern "C" {
    #[doc = " Is this an unhandled exception error handle?\n\n Unhandled exception error handles are produced when, during the\n execution of Dart code, an exception is thrown but not caught.\n This can occur in any function which triggers the execution of Dart\n code.\n\n See Dart_ErrorGetException and Dart_ErrorGetStackTrace.\n\n Requires there to be a current isolate."]
    pub fn Dart_IsUnhandledExceptionError(handle: Dart_Handle) -> bool;
}
unsafe extern "C" {
    #[doc = " Is this a compilation error handle?\n\n Compilation error handles are produced when, during the execution\n of Dart code, a compile-time error occurs.  This can occur in any\n function which triggers the execution of Dart code.\n\n Requires there to be a current isolate."]
    pub fn Dart_IsCompilationError(handle: Dart_Handle) -> bool;
}
unsafe extern "C" {
    #[doc = " Is this a fatal error handle?\n\n Fatal error handles are produced when the system wants to shut down\n the current isolate.\n\n Requires there to be a current isolate."]
    pub fn Dart_IsFatalError(handle: Dart_Handle) -> bool;
}
unsafe extern "C" {
    #[doc = " Gets the error message from an error handle.\n\n Requires there to be a current isolate.\n\n \\return A C string containing an error message if the handle is\n   error. An empty C string (\"\") if the handle is valid. This C\n   String is scope allocated and is only valid until the next call\n   to Dart_ExitScope."]
    pub fn Dart_GetError(handle: Dart_Handle) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Is this an error handle for an unhandled exception?"]
    pub fn Dart_ErrorHasException(handle: Dart_Handle) -> bool;
}
unsafe extern "C" {
    #[doc = " Gets the exception Object from an unhandled exception error handle."]
    pub fn Dart_ErrorGetException(handle: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the stack trace Object from an unhandled exception error handle."]
    pub fn Dart_ErrorGetStackTrace(handle: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Produces an api error handle with the provided error message.\n\n Requires there to be a current isolate.\n\n \\param error the error message."]
    pub fn Dart_NewApiError(error: *const ::std::os::raw::c_char) -> Dart_Handle;
}
unsafe extern "C" {
    pub fn Dart_NewCompilationError(error: *const ::std::os::raw::c_char) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Produces a new unhandled exception error handle.\n\n Requires there to be a current isolate.\n\n \\param exception An instance of a Dart object to be thrown or\n        an ApiError or CompilationError handle.\n        When an ApiError or CompilationError handle is passed in\n        a string object of the error message is created and it becomes\n        the Dart object to be thrown."]
    pub fn Dart_NewUnhandledExceptionError(exception: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Propagates an error.\n\n If the provided handle is an unhandled exception error, this\n function will cause the unhandled exception to be rethrown.  This\n will proceed in the standard way, walking up Dart frames until an\n appropriate 'catch' block is found, executing 'finally' blocks,\n etc.\n\n If the error is not an unhandled exception error, we will unwind\n the stack to the next C frame.  Intervening Dart frames will be\n discarded; specifically, 'finally' blocks will not execute.  This\n is the standard way that compilation errors (and the like) are\n handled by the Dart runtime.\n\n In either case, when an error is propagated any current scopes\n created by Dart_EnterScope will be exited.\n\n See the additional discussion under \"Propagating Errors\" at the\n beginning of this file.\n\n \\param An error handle (See Dart_IsError)\n\n \\return On success, this function does not return.  On failure, the\n process is terminated."]
    pub fn Dart_PropagateError(handle: Dart_Handle);
}
unsafe extern "C" {
    #[doc = " Converts an object to a string.\n\n May generate an unhandled exception error.\n\n \\return The converted string if no error occurs during\n   the conversion. If an error does occur, an error handle is\n   returned."]
    pub fn Dart_ToString(object: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Checks to see if two handles refer to identically equal objects.\n\n If both handles refer to instances, this is equivalent to using the top-level\n function identical() from dart:core. Otherwise, returns whether the two\n argument handles refer to the same object.\n\n \\param obj1 An object to be compared.\n \\param obj2 An object to be compared.\n\n \\return True if the objects are identically equal.  False otherwise."]
    pub fn Dart_IdentityEquals(obj1: Dart_Handle, obj2: Dart_Handle) -> bool;
}
unsafe extern "C" {
    #[doc = " Allocates a handle in the current scope from a persistent handle."]
    pub fn Dart_HandleFromPersistent(object: Dart_PersistentHandle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Allocates a handle in the current scope from a weak persistent handle.\n\n This will be a handle to Dart_Null if the object has been garbage collected."]
    pub fn Dart_HandleFromWeakPersistent(object: Dart_WeakPersistentHandle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Allocates a persistent handle for an object.\n\n This handle has the lifetime of the current isolate unless it is\n explicitly deallocated by calling Dart_DeletePersistentHandle.\n\n Requires there to be a current isolate."]
    pub fn Dart_NewPersistentHandle(object: Dart_Handle) -> Dart_PersistentHandle;
}
unsafe extern "C" {
    #[doc = " Assign value of local handle to a persistent handle.\n\n Requires there to be a current isolate.\n\n \\param obj1 A persistent handle whose value needs to be set.\n \\param obj2 An object whose value needs to be set to the persistent handle.\n\n \\return Success if the persistent handle was set\n   Otherwise, returns an error."]
    pub fn Dart_SetPersistentHandle(obj1: Dart_PersistentHandle, obj2: Dart_Handle);
}
unsafe extern "C" {
    #[doc = " Deallocates a persistent handle.\n\n Requires there to be a current isolate group."]
    pub fn Dart_DeletePersistentHandle(object: Dart_PersistentHandle);
}
unsafe extern "C" {
    #[doc = " Allocates a weak persistent handle for an object.\n\n This handle has the lifetime of the current isolate. The handle can also be\n explicitly deallocated by calling Dart_DeleteWeakPersistentHandle.\n\n If the object becomes unreachable the callback is invoked with the peer as\n argument. The callback can be executed on any thread, will have a current\n isolate group, but will not have a current isolate. The callback can only\n call Dart_DeletePersistentHandle or Dart_DeleteWeakPersistentHandle. This\n gives the embedder the ability to cleanup data associated with the object.\n The handle will point to the Dart_Null object after the finalizer has been\n run. It is illegal to call into the VM with any other Dart_* functions from\n the callback. If the handle is deleted before the object becomes\n unreachable, the callback is never invoked.\n\n Requires there to be a current isolate.\n\n \\param object An object.\n \\param peer A pointer to a native object or NULL.  This value is\n   provided to callback when it is invoked.\n \\param external_allocation_size The number of externally allocated\n   bytes for peer. Used to inform the garbage collector.\n \\param callback A function pointer that will be invoked sometime\n   after the object is garbage collected, unless the handle has been deleted.\n   A valid callback needs to be specified it cannot be NULL.\n\n \\return The weak persistent handle or NULL. NULL is returned in case of bad\n   parameters."]
    pub fn Dart_NewWeakPersistentHandle(
        object: Dart_Handle,
        peer: *mut ::std::os::raw::c_void,
        external_allocation_size: isize,
        callback: Dart_HandleFinalizer,
    ) -> Dart_WeakPersistentHandle;
}
unsafe extern "C" {
    #[doc = " Deletes the given weak persistent [object] handle.\n\n Requires there to be a current isolate group."]
    pub fn Dart_DeleteWeakPersistentHandle(object: Dart_WeakPersistentHandle);
}
unsafe extern "C" {
    #[doc = " Updates the external memory size for the given weak persistent handle.\n\n May trigger garbage collection."]
    pub fn Dart_UpdateExternalSize(
        object: Dart_WeakPersistentHandle,
        external_allocation_size: isize,
    );
}
unsafe extern "C" {
    #[doc = " Allocates a finalizable handle for an object.\n\n This handle has the lifetime of the current isolate group unless the object\n pointed to by the handle is garbage collected, in this case the VM\n automatically deletes the handle after invoking the callback associated\n with the handle. The handle can also be explicitly deallocated by\n calling Dart_DeleteFinalizableHandle.\n\n If the object becomes unreachable the callback is invoked with the\n the peer as argument. The callback can be executed on any thread, will have\n an isolate group, but will not have a current isolate. The callback can only\n call Dart_DeletePersistentHandle or Dart_DeleteWeakPersistentHandle.\n This gives the embedder the ability to cleanup data associated with the\n object and clear out any cached references to the handle. All references to\n this handle after the callback will be invalid. It is illegal to call into\n the VM with any other Dart_* functions from the callback. If the handle is\n deleted before the object becomes unreachable, the callback is never\n invoked.\n\n Requires there to be a current isolate.\n\n \\param object An object.\n \\param peer A pointer to a native object or NULL.  This value is\n   provided to callback when it is invoked.\n \\param external_allocation_size The number of externally allocated\n   bytes for peer. Used to inform the garbage collector.\n \\param callback A function pointer that will be invoked sometime\n   after the object is garbage collected, unless the handle has been deleted.\n   A valid callback needs to be specified it cannot be NULL.\n\n \\return The finalizable handle or NULL. NULL is returned in case of bad\n   parameters."]
    pub fn Dart_NewFinalizableHandle(
        object: Dart_Handle,
        peer: *mut ::std::os::raw::c_void,
        external_allocation_size: isize,
        callback: Dart_HandleFinalizer,
    ) -> Dart_FinalizableHandle;
}
unsafe extern "C" {
    #[doc = " Deletes the given finalizable [object] handle.\n\n The caller has to provide the actual Dart object the handle was created from\n to prove the object (and therefore the finalizable handle) is still alive.\n\n Requires there to be a current isolate."]
    pub fn Dart_DeleteFinalizableHandle(
        object: Dart_FinalizableHandle,
        strong_ref_to_object: Dart_Handle,
    );
}
unsafe extern "C" {
    #[doc = " Updates the external memory size for the given finalizable handle.\n\n The caller has to provide the actual Dart object the handle was created from\n to prove the object (and therefore the finalizable handle) is still alive.\n\n May trigger garbage collection."]
    pub fn Dart_UpdateFinalizableExternalSize(
        object: Dart_FinalizableHandle,
        strong_ref_to_object: Dart_Handle,
        external_allocation_size: isize,
    );
}
unsafe extern "C" {
    #[doc = " Gets the version string for the Dart VM.\n\n The version of the Dart VM can be accessed without initializing the VM.\n\n \\return The version string for the embedded Dart VM."]
    pub fn Dart_VersionString() -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_IsolateFlags {
    pub version: i32,
    pub enable_asserts: bool,
    pub use_field_guards: bool,
    pub use_osr: bool,
    pub obfuscate: bool,
    pub load_vmservice_library: bool,
    pub copy_parent_code: bool,
    pub null_safety: bool,
    pub is_system_isolate: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Dart_IsolateFlags"][::std::mem::size_of::<Dart_IsolateFlags>() - 12usize];
    ["Alignment of Dart_IsolateFlags"][::std::mem::align_of::<Dart_IsolateFlags>() - 4usize];
    ["Offset of field: Dart_IsolateFlags::version"]
        [::std::mem::offset_of!(Dart_IsolateFlags, version) - 0usize];
    ["Offset of field: Dart_IsolateFlags::enable_asserts"]
        [::std::mem::offset_of!(Dart_IsolateFlags, enable_asserts) - 4usize];
    ["Offset of field: Dart_IsolateFlags::use_field_guards"]
        [::std::mem::offset_of!(Dart_IsolateFlags, use_field_guards) - 5usize];
    ["Offset of field: Dart_IsolateFlags::use_osr"]
        [::std::mem::offset_of!(Dart_IsolateFlags, use_osr) - 6usize];
    ["Offset of field: Dart_IsolateFlags::obfuscate"]
        [::std::mem::offset_of!(Dart_IsolateFlags, obfuscate) - 7usize];
    ["Offset of field: Dart_IsolateFlags::load_vmservice_library"]
        [::std::mem::offset_of!(Dart_IsolateFlags, load_vmservice_library) - 8usize];
    ["Offset of field: Dart_IsolateFlags::copy_parent_code"]
        [::std::mem::offset_of!(Dart_IsolateFlags, copy_parent_code) - 9usize];
    ["Offset of field: Dart_IsolateFlags::null_safety"]
        [::std::mem::offset_of!(Dart_IsolateFlags, null_safety) - 10usize];
    ["Offset of field: Dart_IsolateFlags::is_system_isolate"]
        [::std::mem::offset_of!(Dart_IsolateFlags, is_system_isolate) - 11usize];
};
unsafe extern "C" {
    #[doc = " Initialize Dart_IsolateFlags with correct version and default values."]
    pub fn Dart_IsolateFlagsInitialize(flags: *mut Dart_IsolateFlags);
}
#[doc = " An isolate creation and initialization callback function.\n\n This callback, provided by the embedder, is called when the VM\n needs to create an isolate. The callback should create an isolate\n by calling Dart_CreateIsolateGroup and load any scripts required for\n execution.\n\n This callback may be called on a different thread than the one\n running the parent isolate.\n\n When the function returns NULL, it is the responsibility of this\n function to ensure that Dart_ShutdownIsolate has been called if\n required (for example, if the isolate was created successfully by\n Dart_CreateIsolateGroup() but the root library fails to load\n successfully, then the function should call Dart_ShutdownIsolate\n before returning).\n\n When the function returns NULL, the function should set *error to\n a malloc-allocated buffer containing a useful error message.  The\n caller of this function (the VM) will make sure that the buffer is\n freed.\n\n \\param script_uri The uri of the main source file or snapshot to load.\n   Either the URI of the parent isolate set in Dart_CreateIsolateGroup for\n   Isolate.spawn, or the argument to Isolate.spawnUri canonicalized by the\n   library tag handler of the parent isolate.\n   The callback is responsible for loading the program by a call to\n   Dart_LoadScriptFromKernel.\n \\param main The name of the main entry point this isolate will\n   eventually run.  This is provided for advisory purposes only to\n   improve debugging messages.  The main function is not invoked by\n   this function.\n \\param package_root Ignored.\n \\param package_config Uri of the package configuration file (either in format\n   of .packages or .dart_tool/package_config.json) for this isolate\n   to resolve package imports against. If this parameter is not passed the\n   package resolution of the parent isolate should be used.\n \\param flags Default flags for this isolate being spawned. Either inherited\n   from the spawning isolate or passed as parameters when spawning the\n   isolate from Dart code.\n \\param isolate_data The isolate data which was passed to the\n   parent isolate when it was created by calling Dart_CreateIsolateGroup().\n \\param error A structure into which the embedder can place a\n   C string containing an error message in the case of failures.\n\n \\return The embedder returns NULL if the creation and\n   initialization was not successful and the isolate if successful."]
pub type Dart_IsolateGroupCreateCallback = ::std::option::Option<
    unsafe extern "C" fn(
        script_uri: *const ::std::os::raw::c_char,
        main: *const ::std::os::raw::c_char,
        package_root: *const ::std::os::raw::c_char,
        package_config: *const ::std::os::raw::c_char,
        flags: *mut Dart_IsolateFlags,
        isolate_data: *mut ::std::os::raw::c_void,
        error: *mut *mut ::std::os::raw::c_char,
    ) -> Dart_Isolate,
>;
#[doc = " An isolate initialization callback function.\n\n This callback, provided by the embedder, is called when the VM has created an\n isolate within an existing isolate group (i.e. from the same source as an\n existing isolate).\n\n The callback should setup native resolvers and might want to set a custom\n message handler via [Dart_SetMessageNotifyCallback] and mark the isolate as\n runnable.\n\n This callback may be called on a different thread than the one\n running the parent isolate.\n\n When the function returns `false`, it is the responsibility of this\n function to ensure that `Dart_ShutdownIsolate` has been called.\n\n When the function returns `false`, the function should set *error to\n a malloc-allocated buffer containing a useful error message.  The\n caller of this function (the VM) will make sure that the buffer is\n freed.\n\n \\param child_isolate_data The callback data to associate with the new\n        child isolate.\n \\param error A structure into which the embedder can place a\n   C string containing an error message in the case the initialization fails.\n\n \\return The embedder returns true if the initialization was successful and\n         false otherwise (in which case the VM will terminate the isolate)."]
pub type Dart_InitializeIsolateCallback = ::std::option::Option<
    unsafe extern "C" fn(
        child_isolate_data: *mut *mut ::std::os::raw::c_void,
        error: *mut *mut ::std::os::raw::c_char,
    ) -> bool,
>;
#[doc = " An isolate unhandled exception callback function.\n\n This callback has been DEPRECATED."]
pub type Dart_IsolateUnhandledExceptionCallback =
    ::std::option::Option<unsafe extern "C" fn(error: Dart_Handle)>;
#[doc = " An isolate shutdown callback function.\n\n This callback, provided by the embedder, is called before the vm\n shuts down an isolate.  The isolate being shutdown will be the current\n isolate. It is safe to run Dart code.\n\n This function should be used to dispose of native resources that\n are allocated to an isolate in order to avoid leaks.\n\n \\param isolate_group_data The same callback data which was passed to the\n   isolate group when it was created.\n \\param isolate_data The same callback data which was passed to the isolate\n   when it was created."]
pub type Dart_IsolateShutdownCallback = ::std::option::Option<
    unsafe extern "C" fn(
        isolate_group_data: *mut ::std::os::raw::c_void,
        isolate_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " An isolate cleanup callback function.\n\n This callback, provided by the embedder, is called after the vm\n shuts down an isolate. There will be no current isolate and it is *not*\n safe to run Dart code.\n\n This function should be used to dispose of native resources that\n are allocated to an isolate in order to avoid leaks.\n\n \\param isolate_group_data The same callback data which was passed to the\n   isolate group when it was created.\n \\param isolate_data The same callback data which was passed to the isolate\n   when it was created."]
pub type Dart_IsolateCleanupCallback = ::std::option::Option<
    unsafe extern "C" fn(
        isolate_group_data: *mut ::std::os::raw::c_void,
        isolate_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " An isolate group cleanup callback function.\n\n This callback, provided by the embedder, is called after the vm\n shuts down an isolate group.\n\n This function should be used to dispose of native resources that\n are allocated to an isolate in order to avoid leaks.\n\n \\param isolate_group_data The same callback data which was passed to the\n   isolate group when it was created.\n"]
pub type Dart_IsolateGroupCleanupCallback =
    ::std::option::Option<unsafe extern "C" fn(isolate_group_data: *mut ::std::os::raw::c_void)>;
#[doc = " A thread death callback function.\n This callback, provided by the embedder, is called before a thread in the\n vm thread pool exits.\n This function could be used to dispose of native resources that\n are associated and attached to the thread, in order to avoid leaks."]
pub type Dart_ThreadExitCallback = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " Callbacks provided by the embedder for file operations. If the\n embedder does not allow file operations these callbacks can be\n NULL.\n\n Dart_FileOpenCallback - opens a file for reading or writing.\n \\param name The name of the file to open.\n \\param write A boolean variable which indicates if the file is to\n   opened for writing. If there is an existing file it needs to truncated.\n\n Dart_FileReadCallback - Read contents of file.\n \\param data Buffer allocated in the callback into which the contents\n   of the file are read into. It is the responsibility of the caller to\n   free this buffer.\n \\param file_length A variable into which the length of the file is returned.\n   In the case of an error this value would be -1.\n \\param stream Handle to the opened file.\n\n Dart_FileWriteCallback - Write data into file.\n \\param data Buffer which needs to be written into the file.\n \\param length Length of the buffer.\n \\param stream Handle to the opened file.\n\n Dart_FileCloseCallback - Closes the opened file.\n \\param stream Handle to the opened file.\n"]
pub type Dart_FileOpenCallback = ::std::option::Option<
    unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
        write: bool,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type Dart_FileReadCallback = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut *mut u8,
        file_length: *mut isize,
        stream: *mut ::std::os::raw::c_void,
    ),
>;
pub type Dart_FileWriteCallback = ::std::option::Option<
    unsafe extern "C" fn(
        data: *const ::std::os::raw::c_void,
        length: isize,
        stream: *mut ::std::os::raw::c_void,
    ),
>;
pub type Dart_FileCloseCallback =
    ::std::option::Option<unsafe extern "C" fn(stream: *mut ::std::os::raw::c_void)>;
pub type Dart_EntropySource =
    ::std::option::Option<unsafe extern "C" fn(buffer: *mut u8, length: isize) -> bool>;
#[doc = " Callback provided by the embedder that is used by the vmservice isolate\n to request the asset archive. The asset archive must be an uncompressed tar\n archive that is stored in a Uint8List.\n\n If the embedder has no vmservice isolate assets, the callback can be NULL.\n\n \\return The embedder must return a handle to a Uint8List containing an\n   uncompressed tar archive or null."]
pub type Dart_GetVMServiceAssetsArchive =
    ::std::option::Option<unsafe extern "C" fn() -> Dart_Handle>;
#[doc = " Callback provided by the embedder that is used by the VM to notify on code\n object creation, *before* it is invoked the first time.\n This is useful for embedders wanting to e.g. keep track of PCs beyond\n the lifetime of the garbage collected code objects.\n Note that an address range may be used by more than one code object over the\n lifecycle of a process. Clients of this function should record timestamps for\n these compilation events and when collecting PCs to disambiguate reused\n address ranges."]
pub type Dart_OnNewCodeCallback = ::std::option::Option<
    unsafe extern "C" fn(
        observer: *mut Dart_CodeObserver,
        name: *const ::std::os::raw::c_char,
        base: usize,
        size: usize,
    ),
>;
#[doc = " Forward declaration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_CodeObserver {
    pub data: *mut ::std::os::raw::c_void,
    pub on_new_code: Dart_OnNewCodeCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Dart_CodeObserver"][::std::mem::size_of::<Dart_CodeObserver>() - 16usize];
    ["Alignment of Dart_CodeObserver"][::std::mem::align_of::<Dart_CodeObserver>() - 8usize];
    ["Offset of field: Dart_CodeObserver::data"]
        [::std::mem::offset_of!(Dart_CodeObserver, data) - 0usize];
    ["Offset of field: Dart_CodeObserver::on_new_code"]
        [::std::mem::offset_of!(Dart_CodeObserver, on_new_code) - 8usize];
};
#[doc = " Describes how to initialize the VM. Used with Dart_Initialize.\n\n \\param version Identifies the version of the struct used by the client.\n   should be initialized to DART_INITIALIZE_PARAMS_CURRENT_VERSION.\n \\param vm_isolate_snapshot A buffer containing a snapshot of the VM isolate\n   or NULL if no snapshot is provided. If provided, the buffer must remain\n   valid until Dart_Cleanup returns.\n \\param instructions_snapshot A buffer containing a snapshot of precompiled\n   instructions, or NULL if no snapshot is provided. If provided, the buffer\n   must remain valid until Dart_Cleanup returns.\n \\param initialize_isolate A function to be called during isolate\n   initialization inside an existing isolate group.\n   See Dart_InitializeIsolateCallback.\n \\param create_group A function to be called during isolate group creation.\n   See Dart_IsolateGroupCreateCallback.\n \\param shutdown A function to be called right before an isolate is shutdown.\n   See Dart_IsolateShutdownCallback.\n \\param cleanup A function to be called after an isolate was shutdown.\n   See Dart_IsolateCleanupCallback.\n \\param cleanup_group A function to be called after an isolate group is shutdown.\n   See Dart_IsolateGroupCleanupCallback.\n \\param get_service_assets A function to be called by the service isolate when\n    it requires the vmservice assets archive.\n    See Dart_GetVMServiceAssetsArchive.\n \\param code_observer An external code observer callback function.\n    The observer can be invoked as early as during the Dart_Initialize() call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_InitializeParams {
    pub version: i32,
    pub vm_snapshot_data: *const u8,
    pub vm_snapshot_instructions: *const u8,
    pub create_group: Dart_IsolateGroupCreateCallback,
    pub initialize_isolate: Dart_InitializeIsolateCallback,
    pub shutdown_isolate: Dart_IsolateShutdownCallback,
    pub cleanup_isolate: Dart_IsolateCleanupCallback,
    pub cleanup_group: Dart_IsolateGroupCleanupCallback,
    pub thread_exit: Dart_ThreadExitCallback,
    pub file_open: Dart_FileOpenCallback,
    pub file_read: Dart_FileReadCallback,
    pub file_write: Dart_FileWriteCallback,
    pub file_close: Dart_FileCloseCallback,
    pub entropy_source: Dart_EntropySource,
    pub get_service_assets: Dart_GetVMServiceAssetsArchive,
    pub start_kernel_isolate: bool,
    pub code_observer: *mut Dart_CodeObserver,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Dart_InitializeParams"][::std::mem::size_of::<Dart_InitializeParams>() - 136usize];
    ["Alignment of Dart_InitializeParams"]
        [::std::mem::align_of::<Dart_InitializeParams>() - 8usize];
    ["Offset of field: Dart_InitializeParams::version"]
        [::std::mem::offset_of!(Dart_InitializeParams, version) - 0usize];
    ["Offset of field: Dart_InitializeParams::vm_snapshot_data"]
        [::std::mem::offset_of!(Dart_InitializeParams, vm_snapshot_data) - 8usize];
    ["Offset of field: Dart_InitializeParams::vm_snapshot_instructions"]
        [::std::mem::offset_of!(Dart_InitializeParams, vm_snapshot_instructions) - 16usize];
    ["Offset of field: Dart_InitializeParams::create_group"]
        [::std::mem::offset_of!(Dart_InitializeParams, create_group) - 24usize];
    ["Offset of field: Dart_InitializeParams::initialize_isolate"]
        [::std::mem::offset_of!(Dart_InitializeParams, initialize_isolate) - 32usize];
    ["Offset of field: Dart_InitializeParams::shutdown_isolate"]
        [::std::mem::offset_of!(Dart_InitializeParams, shutdown_isolate) - 40usize];
    ["Offset of field: Dart_InitializeParams::cleanup_isolate"]
        [::std::mem::offset_of!(Dart_InitializeParams, cleanup_isolate) - 48usize];
    ["Offset of field: Dart_InitializeParams::cleanup_group"]
        [::std::mem::offset_of!(Dart_InitializeParams, cleanup_group) - 56usize];
    ["Offset of field: Dart_InitializeParams::thread_exit"]
        [::std::mem::offset_of!(Dart_InitializeParams, thread_exit) - 64usize];
    ["Offset of field: Dart_InitializeParams::file_open"]
        [::std::mem::offset_of!(Dart_InitializeParams, file_open) - 72usize];
    ["Offset of field: Dart_InitializeParams::file_read"]
        [::std::mem::offset_of!(Dart_InitializeParams, file_read) - 80usize];
    ["Offset of field: Dart_InitializeParams::file_write"]
        [::std::mem::offset_of!(Dart_InitializeParams, file_write) - 88usize];
    ["Offset of field: Dart_InitializeParams::file_close"]
        [::std::mem::offset_of!(Dart_InitializeParams, file_close) - 96usize];
    ["Offset of field: Dart_InitializeParams::entropy_source"]
        [::std::mem::offset_of!(Dart_InitializeParams, entropy_source) - 104usize];
    ["Offset of field: Dart_InitializeParams::get_service_assets"]
        [::std::mem::offset_of!(Dart_InitializeParams, get_service_assets) - 112usize];
    ["Offset of field: Dart_InitializeParams::start_kernel_isolate"]
        [::std::mem::offset_of!(Dart_InitializeParams, start_kernel_isolate) - 120usize];
    ["Offset of field: Dart_InitializeParams::code_observer"]
        [::std::mem::offset_of!(Dart_InitializeParams, code_observer) - 128usize];
};
unsafe extern "C" {
    #[doc = " Initializes the VM.\n\n \\param params A struct containing initialization information. The version\n   field of the struct must be DART_INITIALIZE_PARAMS_CURRENT_VERSION.\n\n \\return NULL if initialization is successful. Returns an error message\n   otherwise. The caller is responsible for freeing the error message."]
    pub fn Dart_Initialize(params: *mut Dart_InitializeParams) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Cleanup state in the VM before process termination.\n\n \\return NULL if cleanup is successful. Returns an error message otherwise.\n   The caller is responsible for freeing the error message.\n\n NOTE: This function must not be called on a thread that was created by the VM\n itself."]
    pub fn Dart_Cleanup() -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Sets command line flags. Should be called before Dart_Initialize.\n\n \\param argc The length of the arguments array.\n \\param argv An array of arguments.\n\n \\return NULL if successful. Returns an error message otherwise.\n  The caller is responsible for freeing the error message.\n\n NOTE: This call does not store references to the passed in c-strings."]
    pub fn Dart_SetVMFlags(
        argc: ::std::os::raw::c_int,
        argv: *mut *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns true if the named VM flag is of boolean type, specified, and set to\n true.\n\n \\param flag_name The name of the flag without leading punctuation\n                  (example: \"enable_asserts\")."]
    pub fn Dart_IsVMFlagSet(flag_name: *const ::std::os::raw::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a new isolate. The new isolate becomes the current isolate.\n\n A snapshot can be used to restore the VM quickly to a saved state\n and is useful for fast startup. If snapshot data is provided, the\n isolate will be started using that snapshot data. Requires a core snapshot or\n an app snapshot created by Dart_CreateSnapshot or\n Dart_CreatePrecompiledSnapshot* from a VM with the same version.\n\n Requires there to be no current isolate.\n\n \\param script_uri The main source file or snapshot this isolate will load.\n   The VM will provide this URI to the Dart_IsolateGroupCreateCallback when a child\n   isolate is created by Isolate.spawn. The embedder should use a URI that\n   allows it to load the same program into such a child isolate.\n \\param name A short name for the isolate to improve debugging messages.\n   Typically of the format 'foo.dart:main()'.\n \\param isolate_snapshot_data\n \\param isolate_snapshot_instructions Buffers containing a snapshot of the\n   isolate or NULL if no snapshot is provided. If provided, the buffers must\n   remain valid until the isolate shuts down.\n \\param flags Pointer to VM specific flags or NULL for default flags.\n \\param isolate_group_data Embedder group data. This data can be obtained\n   by calling Dart_IsolateGroupData and will be passed to the\n   Dart_IsolateShutdownCallback, Dart_IsolateCleanupCallback, and\n   Dart_IsolateGroupCleanupCallback.\n \\param isolate_data Embedder data.  This data will be passed to\n   the Dart_IsolateGroupCreateCallback when new isolates are spawned from\n   this parent isolate.\n \\param error Returns NULL if creation is successful, an error message\n   otherwise. The caller is responsible for calling free() on the error\n   message.\n\n \\return The new isolate on success, or NULL if isolate creation failed."]
    pub fn Dart_CreateIsolateGroup(
        script_uri: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        isolate_snapshot_data: *const u8,
        isolate_snapshot_instructions: *const u8,
        flags: *mut Dart_IsolateFlags,
        isolate_group_data: *mut ::std::os::raw::c_void,
        isolate_data: *mut ::std::os::raw::c_void,
        error: *mut *mut ::std::os::raw::c_char,
    ) -> Dart_Isolate;
}
unsafe extern "C" {
    #[doc = " Creates a new isolate inside the isolate group of [group_member].\n\n Requires there to be no current isolate.\n\n \\param group_member An isolate from the same group into which the newly created\n   isolate should be born into. Other threads may not have entered / enter this\n   member isolate.\n \\param name A short name for the isolate for debugging purposes.\n \\param shutdown_callback A callback to be called when the isolate is being\n   shutdown (may be NULL).\n \\param cleanup_callback A callback to be called when the isolate is being\n   cleaned up (may be NULL).\n \\param isolate_data The embedder-specific data associated with this isolate.\n \\param error Set to NULL if creation is successful, set to an error\n   message otherwise. The caller is responsible for calling free() on the\n   error message.\n\n \\return The newly created isolate on success, or NULL if isolate creation\n   failed.\n\n If successful, the newly created isolate will become the current isolate."]
    pub fn Dart_CreateIsolateInGroup(
        group_member: Dart_Isolate,
        name: *const ::std::os::raw::c_char,
        shutdown_callback: Dart_IsolateShutdownCallback,
        cleanup_callback: Dart_IsolateCleanupCallback,
        child_isolate_data: *mut ::std::os::raw::c_void,
        error: *mut *mut ::std::os::raw::c_char,
    ) -> Dart_Isolate;
}
unsafe extern "C" {
    #[doc = " Creates a new isolate from a Dart Kernel file. The new isolate\n becomes the current isolate.\n\n Requires there to be no current isolate.\n\n \\param script_uri The main source file or snapshot this isolate will load.\n   The VM will provide this URI to the Dart_IsolateGroupCreateCallback when a child\n   isolate is created by Isolate.spawn. The embedder should use a URI that\n   allows it to load the same program into such a child isolate.\n \\param name A short name for the isolate to improve debugging messages.\n   Typically of the format 'foo.dart:main()'.\n \\param kernel_buffer\n \\param kernel_buffer_size A buffer which contains a kernel/DIL program. Must\n   remain valid until isolate shutdown.\n \\param flags Pointer to VM specific flags or NULL for default flags.\n \\param isolate_group_data Embedder group data. This data can be obtained\n   by calling Dart_IsolateGroupData and will be passed to the\n   Dart_IsolateShutdownCallback, Dart_IsolateCleanupCallback, and\n   Dart_IsolateGroupCleanupCallback.\n \\param isolate_data Embedder data.  This data will be passed to\n   the Dart_IsolateGroupCreateCallback when new isolates are spawned from\n   this parent isolate.\n \\param error Returns NULL if creation is successful, an error message\n   otherwise. The caller is responsible for calling free() on the error\n   message.\n\n \\return The new isolate on success, or NULL if isolate creation failed."]
    pub fn Dart_CreateIsolateGroupFromKernel(
        script_uri: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        kernel_buffer: *const u8,
        kernel_buffer_size: isize,
        flags: *mut Dart_IsolateFlags,
        isolate_group_data: *mut ::std::os::raw::c_void,
        isolate_data: *mut ::std::os::raw::c_void,
        error: *mut *mut ::std::os::raw::c_char,
    ) -> Dart_Isolate;
}
unsafe extern "C" {
    #[doc = " Shuts down the current isolate. After this call, the current isolate is NULL.\n Any current scopes created by Dart_EnterScope will be exited. Invokes the\n shutdown callback and any callbacks of remaining weak persistent handles.\n\n Requires there to be a current isolate."]
    pub fn Dart_ShutdownIsolate();
}
unsafe extern "C" {
    #[doc = " Returns the current isolate. Will return NULL if there is no\n current isolate."]
    pub fn Dart_CurrentIsolate() -> Dart_Isolate;
}
unsafe extern "C" {
    #[doc = " Returns the callback data associated with the current isolate. This\n data was set when the isolate got created or initialized."]
    pub fn Dart_CurrentIsolateData() -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Returns the callback data associated with the given isolate. This\n data was set when the isolate got created or initialized."]
    pub fn Dart_IsolateData(isolate: Dart_Isolate) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Returns the current isolate group. Will return NULL if there is no\n current isolate group."]
    pub fn Dart_CurrentIsolateGroup() -> Dart_IsolateGroup;
}
unsafe extern "C" {
    #[doc = " Returns the callback data associated with the current isolate group. This\n data was passed to the isolate group when it was created."]
    pub fn Dart_CurrentIsolateGroupData() -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Returns the callback data associated with the specified isolate group. This\n data was passed to the isolate when it was created.\n The embedder is responsible for ensuring the consistency of this data\n with respect to the lifecycle of an isolate group."]
    pub fn Dart_IsolateGroupData(isolate: Dart_Isolate) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Returns the debugging name for the current isolate.\n\n This name is unique to each isolate and should only be used to make\n debugging messages more comprehensible."]
    pub fn Dart_DebugName() -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns the ID for an isolate which is used to query the service protocol.\n\n It is the responsibility of the caller to free the returned ID."]
    pub fn Dart_IsolateServiceId(isolate: Dart_Isolate) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Enters an isolate. After calling this function,\n the current isolate will be set to the provided isolate.\n\n Requires there to be no current isolate. Multiple threads may not be in\n the same isolate at once."]
    pub fn Dart_EnterIsolate(isolate: Dart_Isolate);
}
unsafe extern "C" {
    #[doc = " Kills the given isolate.\n\n This function has the same effect as dart:isolate's\n Isolate.kill(priority:immediate).\n It can interrupt ordinary Dart code but not native code. If the isolate is\n in the middle of a long running native function, the isolate will not be\n killed until control returns to Dart.\n\n Does not require a current isolate. It is safe to kill the current isolate if\n there is one."]
    pub fn Dart_KillIsolate(isolate: Dart_Isolate);
}
unsafe extern "C" {
    #[doc = " Notifies the VM that the embedder expects |size| bytes of memory have become\n unreachable. The VM may use this hint to adjust the garbage collector's\n growth policy.\n\n Multiple calls are interpreted as increasing, not replacing, the estimate of\n unreachable memory.\n\n Requires there to be a current isolate."]
    pub fn Dart_HintFreed(size: isize);
}
unsafe extern "C" {
    #[doc = " Notifies the VM that the embedder expects to be idle until |deadline|. The VM\n may use this time to perform garbage collection or other tasks to avoid\n delays during execution of Dart code in the future.\n\n |deadline| is measured in microseconds against the system's monotonic time.\n This clock can be accessed via Dart_TimelineGetMicros().\n\n Requires there to be a current isolate."]
    pub fn Dart_NotifyIdle(deadline: i64);
}
unsafe extern "C" {
    #[doc = " Notifies the VM that the system is running low on memory.\n\n Does not require a current isolate. Only valid after calling Dart_Initialize."]
    pub fn Dart_NotifyLowMemory();
}
unsafe extern "C" {
    #[doc = " Starts the CPU sampling profiler."]
    pub fn Dart_StartProfiling();
}
unsafe extern "C" {
    #[doc = " Stops the CPU sampling profiler.\n\n Note that some profile samples might still be taken after this fucntion\n returns due to the asynchronous nature of the implementation on some\n platforms."]
    pub fn Dart_StopProfiling();
}
unsafe extern "C" {
    #[doc = " Notifies the VM that the current thread should not be profiled until a\n matching call to Dart_ThreadEnableProfiling is made.\n\n NOTE: By default, if a thread has entered an isolate it will be profiled.\n This function should be used when an embedder knows a thread is about\n to make a blocking call and wants to avoid unnecessary interrupts by\n the profiler."]
    pub fn Dart_ThreadDisableProfiling();
}
unsafe extern "C" {
    #[doc = " Notifies the VM that the current thread should be profiled.\n\n NOTE: It is only legal to call this function *after* calling\n   Dart_ThreadDisableProfiling.\n\n NOTE: By default, if a thread has entered an isolate it will be profiled."]
    pub fn Dart_ThreadEnableProfiling();
}
unsafe extern "C" {
    #[doc = " Register symbol information for the Dart VM's profiler and crash dumps.\n\n This consumes the output of //topaz/runtime/dart/profiler_symbols, which\n should be treated as opaque."]
    pub fn Dart_AddSymbols(
        dso_name: *const ::std::os::raw::c_char,
        buffer: *mut ::std::os::raw::c_void,
        buffer_size: isize,
    );
}
unsafe extern "C" {
    #[doc = " Exits an isolate. After this call, Dart_CurrentIsolate will\n return NULL.\n\n Requires there to be a current isolate."]
    pub fn Dart_ExitIsolate();
}
unsafe extern "C" {
    #[doc = " Creates a full snapshot of the current isolate heap.\n\n A full snapshot is a compact representation of the dart vm isolate heap\n and dart isolate heap states. These snapshots are used to initialize\n the vm isolate on startup and fast initialization of an isolate.\n A Snapshot of the heap is created before any dart code has executed.\n\n Requires there to be a current isolate. Not available in the precompiled\n runtime (check Dart_IsPrecompiledRuntime).\n\n \\param buffer Returns a pointer to a buffer containing the\n   snapshot. This buffer is scope allocated and is only valid\n   until the next call to Dart_ExitScope.\n \\param size Returns the size of the buffer.\n \\param is_core Create a snapshot containing core libraries.\n                Such snapshot should be agnostic to null safety mode.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_CreateSnapshot(
        vm_snapshot_data_buffer: *mut *mut u8,
        vm_snapshot_data_size: *mut isize,
        isolate_snapshot_data_buffer: *mut *mut u8,
        isolate_snapshot_data_size: *mut isize,
        is_core: bool,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns whether the buffer contains a kernel file.\n\n \\param buffer Pointer to a buffer that might contain a kernel binary.\n \\param buffer_size Size of the buffer.\n\n \\return Whether the buffer contains a kernel binary (full or partial)."]
    pub fn Dart_IsKernel(buffer: *const u8, buffer_size: isize) -> bool;
}
unsafe extern "C" {
    #[doc = " Make isolate runnable.\n\n When isolates are spawned, this function is used to indicate that\n the creation and initialization (including script loading) of the\n isolate is complete and the isolate can start.\n This function expects there to be no current isolate.\n\n \\param isolate The isolate to be made runnable.\n\n \\return NULL if successful. Returns an error message otherwise. The caller\n is responsible for freeing the error message."]
    pub fn Dart_IsolateMakeRunnable(isolate: Dart_Isolate) -> *mut ::std::os::raw::c_char;
}
#[doc = " A port is used to send or receive inter-isolate messages"]
pub type Dart_Port = i64;
#[doc = " A message notification callback.\n\n This callback allows the embedder to provide an alternate wakeup\n mechanism for the delivery of inter-isolate messages.  It is the\n responsibility of the embedder to call Dart_HandleMessage to\n process the message."]
pub type Dart_MessageNotifyCallback =
    ::std::option::Option<unsafe extern "C" fn(dest_isolate: Dart_Isolate)>;
unsafe extern "C" {
    #[doc = " Allows embedders to provide an alternative wakeup mechanism for the\n delivery of inter-isolate messages. This setting only applies to\n the current isolate.\n\n Most embedders will only call this function once, before isolate\n execution begins. If this function is called after isolate\n execution begins, the embedder is responsible for threading issues."]
    pub fn Dart_SetMessageNotifyCallback(message_notify_callback: Dart_MessageNotifyCallback);
}
unsafe extern "C" {
    #[doc = " Query the current message notify callback for the isolate.\n\n \\return The current message notify callback for the isolate."]
    pub fn Dart_GetMessageNotifyCallback() -> Dart_MessageNotifyCallback;
}
unsafe extern "C" {
    #[doc = " If the VM flag `--pause-isolates-on-start` was passed this will be true.\n\n \\return A boolean value indicating if pause on start was requested."]
    pub fn Dart_ShouldPauseOnStart() -> bool;
}
unsafe extern "C" {
    #[doc = " Override the VM flag `--pause-isolates-on-start` for the current isolate.\n\n \\param should_pause Should the isolate be paused on start?\n\n NOTE: This must be called before Dart_IsolateMakeRunnable."]
    pub fn Dart_SetShouldPauseOnStart(should_pause: bool);
}
unsafe extern "C" {
    #[doc = " Is the current isolate paused on start?\n\n \\return A boolean value indicating if the isolate is paused on start."]
    pub fn Dart_IsPausedOnStart() -> bool;
}
unsafe extern "C" {
    #[doc = " Called when the embedder has paused the current isolate on start and when\n the embedder has resumed the isolate.\n\n \\param paused Is the isolate paused on start?"]
    pub fn Dart_SetPausedOnStart(paused: bool);
}
unsafe extern "C" {
    #[doc = " If the VM flag `--pause-isolates-on-exit` was passed this will be true.\n\n \\return A boolean value indicating if pause on exit was requested."]
    pub fn Dart_ShouldPauseOnExit() -> bool;
}
unsafe extern "C" {
    #[doc = " Override the VM flag `--pause-isolates-on-exit` for the current isolate.\n\n \\param should_pause Should the isolate be paused on exit?\n"]
    pub fn Dart_SetShouldPauseOnExit(should_pause: bool);
}
unsafe extern "C" {
    #[doc = " Is the current isolate paused on exit?\n\n \\return A boolean value indicating if the isolate is paused on exit."]
    pub fn Dart_IsPausedOnExit() -> bool;
}
unsafe extern "C" {
    #[doc = " Called when the embedder has paused the current isolate on exit and when\n the embedder has resumed the isolate.\n\n \\param paused Is the isolate paused on exit?"]
    pub fn Dart_SetPausedOnExit(paused: bool);
}
unsafe extern "C" {
    #[doc = " Called when the embedder has caught a top level unhandled exception error\n in the current isolate.\n\n NOTE: It is illegal to call this twice on the same isolate without first\n clearing the sticky error to null.\n\n \\param error The unhandled exception error."]
    pub fn Dart_SetStickyError(error: Dart_Handle);
}
unsafe extern "C" {
    #[doc = " Does the current isolate have a sticky error?"]
    pub fn Dart_HasStickyError() -> bool;
}
unsafe extern "C" {
    #[doc = " Gets the sticky error for the current isolate.\n\n \\return A handle to the sticky error object or null."]
    pub fn Dart_GetStickyError() -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Handles the next pending message for the current isolate.\n\n May generate an unhandled exception error.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_HandleMessage() -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Drains the microtask queue, then blocks the calling thread until the current\n isolate recieves a message, then handles all messages.\n\n \\param timeout_millis When non-zero, the call returns after the indicated\nnumber of milliseconds even if no message was received.\n \\return A valid handle if no error occurs, otherwise an error handle."]
    pub fn Dart_WaitForEvent(timeout_millis: i64) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Handles any pending messages for the vm service for the current\n isolate.\n\n This function may be used by an embedder at a breakpoint to avoid\n pausing the vm service.\n\n This function can indirectly cause the message notify callback to\n be called.\n\n \\return true if the vm service requests the program resume\n execution, false otherwise"]
    pub fn Dart_HandleServiceMessages() -> bool;
}
unsafe extern "C" {
    #[doc = " Does the current isolate have pending service messages?\n\n \\return true if the isolate has pending service messages, false otherwise."]
    pub fn Dart_HasServiceMessages() -> bool;
}
unsafe extern "C" {
    #[doc = " Processes any incoming messages for the current isolate.\n\n This function may only be used when the embedder has not provided\n an alternate message delivery mechanism with\n Dart_SetMessageCallbacks. It is provided for convenience.\n\n This function waits for incoming messages for the current\n isolate. As new messages arrive, they are handled using\n Dart_HandleMessage. The routine exits when all ports to the\n current isolate are closed.\n\n \\return A valid handle if the run loop exited successfully.  If an\n   exception or other error occurs while processing messages, an\n   error handle is returned."]
    pub fn Dart_RunLoop() -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Lets the VM run message processing for the isolate.\n\n This function expects there to a current isolate and the current isolate\n must not have an active api scope. The VM will take care of making the\n isolate runnable (if not already), handles its message loop and will take\n care of shutting the isolate down once it's done.\n\n \\param errors_are_fatal Whether uncaught errors should be fatal.\n \\param on_error_port A port to notify on uncaught errors (or ILLEGAL_PORT).\n \\param on_exit_port A port to notify on exit (or ILLEGAL_PORT).\n \\param error A non-NULL pointer which will hold an error message if the call\n   fails. The error has to be free()ed by the caller.\n\n \\return If successfull the VM takes owernship of the isolate and takes care\n   of its message loop. If not successful the caller retains owernship of the\n   isolate."]
    pub fn Dart_RunLoopAsync(
        errors_are_fatal: bool,
        on_error_port: Dart_Port,
        on_exit_port: Dart_Port,
        error: *mut *mut ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Gets the main port id for the current isolate."]
    pub fn Dart_GetMainPortId() -> Dart_Port;
}
unsafe extern "C" {
    #[doc = " Does the current isolate have live ReceivePorts?\n\n A ReceivePort is live when it has not been closed."]
    pub fn Dart_HasLivePorts() -> bool;
}
unsafe extern "C" {
    #[doc = " Posts a message for some isolate. The message is a serialized\n object.\n\n Requires there to be a current isolate.\n\n \\param port The destination port.\n \\param object An object from the current isolate.\n\n \\return True if the message was posted."]
    pub fn Dart_Post(port_id: Dart_Port, object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns a new SendPort with the provided port id.\n\n \\param port_id The destination port.\n\n \\return A new SendPort if no errors occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewSendPort(port_id: Dart_Port) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the SendPort id for the provided SendPort.\n \\param port A SendPort object whose id is desired.\n \\param port_id Returns the id of the SendPort.\n \\return Success if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_SendPortGetId(port: Dart_Handle, port_id: *mut Dart_Port) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Enters a new scope.\n\n All new local handles will be created in this scope. Additionally,\n some functions may return \"scope allocated\" memory which is only\n valid within this scope.\n\n Requires there to be a current isolate."]
    pub fn Dart_EnterScope();
}
unsafe extern "C" {
    #[doc = " Exits a scope.\n\n The previous scope (if any) becomes the current scope.\n\n Requires there to be a current isolate."]
    pub fn Dart_ExitScope();
}
unsafe extern "C" {
    #[doc = " The Dart VM uses \"zone allocation\" for temporary structures. Zones\n support very fast allocation of small chunks of memory. The chunks\n cannot be deallocated individually, but instead zones support\n deallocating all chunks in one fast operation.\n\n This function makes it possible for the embedder to allocate\n temporary data in the VMs zone allocator.\n\n Zone allocation is possible:\n   1. when inside a scope where local handles can be allocated\n   2. when processing a message from a native port in a native port\n      handler\n\n All the memory allocated this way will be reclaimed either on the\n next call to Dart_ExitScope or when the native port handler exits.\n\n \\param size Size of the memory to allocate.\n\n \\return A pointer to the allocated memory. NULL if allocation\n   failed. Failure might due to is no current VM zone."]
    pub fn Dart_ScopeAllocate(size: isize) -> *mut u8;
}
unsafe extern "C" {
    #[doc = " Returns the null object.\n\n \\return A handle to the null object."]
    pub fn Dart_Null() -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Is this object null?"]
    pub fn Dart_IsNull(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the empty string object.\n\n \\return A handle to the empty string object."]
    pub fn Dart_EmptyString() -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns types that are not classes, and which therefore cannot be looked up\n as library members by Dart_GetType.\n\n \\return A handle to the dynamic, void or Never type."]
    pub fn Dart_TypeDynamic() -> Dart_Handle;
}
unsafe extern "C" {
    pub fn Dart_TypeVoid() -> Dart_Handle;
}
unsafe extern "C" {
    pub fn Dart_TypeNever() -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Checks if the two objects are equal.\n\n The result of the comparison is returned through the 'equal'\n parameter. The return value itself is used to indicate success or\n failure, not equality.\n\n May generate an unhandled exception error.\n\n \\param obj1 An object to be compared.\n \\param obj2 An object to be compared.\n \\param equal Returns the result of the equality comparison.\n\n \\return A valid handle if no error occurs during the comparison."]
    pub fn Dart_ObjectEquals(obj1: Dart_Handle, obj2: Dart_Handle, equal: *mut bool)
        -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Is this object an instance of some type?\n\n The result of the test is returned through the 'instanceof' parameter.\n The return value itself is used to indicate success or failure.\n\n \\param object An object.\n \\param type A type.\n \\param instanceof Return true if 'object' is an instance of type 'type'.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_ObjectIsType(
        object: Dart_Handle,
        type_: Dart_Handle,
        instanceof: *mut bool,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Query object type.\n\n \\param object Some Object.\n\n \\return true if Object is of the specified type."]
    pub fn Dart_IsInstance(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsNumber(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsInteger(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsDouble(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsBoolean(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsString(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsStringLatin1(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsExternalString(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsList(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsMap(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsLibrary(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsType(handle: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsFunction(handle: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsVariable(handle: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsTypeVariable(handle: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsClosure(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsTypedData(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsByteBuffer(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsFuture(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    #[doc = " Gets the type of a Dart language object.\n\n \\param instance Some Dart object.\n\n \\return If no error occurs, the type is returned. Otherwise an\n   error handle is returned."]
    pub fn Dart_InstanceGetType(instance: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns the name for the provided class type.\n\n \\return A valid string handle if no error occurs during the\n   operation."]
    pub fn Dart_ClassName(cls_type: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns the name for the provided function or method.\n\n \\return A valid string handle if no error occurs during the\n   operation."]
    pub fn Dart_FunctionName(function: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a handle to the owner of a function.\n\n The owner of an instance method or a static method is its defining\n class. The owner of a top-level function is its defining\n library. The owner of the function of a non-implicit closure is the\n function of the method or closure that defines the non-implicit\n closure.\n\n \\return A valid handle to the owner of the function, or an error\n   handle if the argument is not a valid handle to a function."]
    pub fn Dart_FunctionOwner(function: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Determines whether a function handle referes to a static function\n of method.\n\n For the purposes of the embedding API, a top-level function is\n implicitly declared static.\n\n \\param function A handle to a function or method declaration.\n \\param is_static Returns whether the function or method is declared static.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_FunctionIsStatic(function: Dart_Handle, is_static: *mut bool) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Is this object a closure resulting from a tear-off (closurized method)?\n\n Returns true for closures produced when an ordinary method is accessed\n through a getter call. Returns false otherwise, in particular for closures\n produced from local function declarations.\n\n \\param object Some Object.\n\n \\return true if Object is a tear-off."]
    pub fn Dart_IsTearOff(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    #[doc = " Retrieves the function of a closure.\n\n \\return A handle to the function of the closure, or an error handle if the\n   argument is not a closure."]
    pub fn Dart_ClosureFunction(closure: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a handle to the library which contains class.\n\n \\return A valid handle to the library with owns class, null if the class\n   has no library or an error handle if the argument is not a valid handle\n   to a class type."]
    pub fn Dart_ClassLibrary(cls_type: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Does this Integer fit into a 64-bit signed integer?\n\n \\param integer An integer.\n \\param fits Returns true if the integer fits into a 64-bit signed integer.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_IntegerFitsIntoInt64(integer: Dart_Handle, fits: *mut bool) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Does this Integer fit into a 64-bit unsigned integer?\n\n \\param integer An integer.\n \\param fits Returns true if the integer fits into a 64-bit unsigned integer.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_IntegerFitsIntoUint64(integer: Dart_Handle, fits: *mut bool) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns an Integer with the provided value.\n\n \\param value The value of the integer.\n\n \\return The Integer object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewInteger(value: i64) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns an Integer with the provided value.\n\n \\param value The unsigned value of the integer.\n\n \\return The Integer object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewIntegerFromUint64(value: u64) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns an Integer with the provided value.\n\n \\param value The value of the integer represented as a C string\n   containing a hexadecimal number.\n\n \\return The Integer object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewIntegerFromHexCString(value: *const ::std::os::raw::c_char) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the value of an Integer.\n\n The integer must fit into a 64-bit signed integer, otherwise an error occurs.\n\n \\param integer An Integer.\n \\param value Returns the value of the Integer.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_IntegerToInt64(integer: Dart_Handle, value: *mut i64) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the value of an Integer.\n\n The integer must fit into a 64-bit unsigned integer, otherwise an\n error occurs.\n\n \\param integer An Integer.\n \\param value Returns the value of the Integer.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_IntegerToUint64(integer: Dart_Handle, value: *mut u64) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the value of an integer as a hexadecimal C string.\n\n \\param integer An Integer.\n \\param value Returns the value of the Integer as a hexadecimal C\n   string. This C string is scope allocated and is only valid until\n   the next call to Dart_ExitScope.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_IntegerToHexCString(
        integer: Dart_Handle,
        value: *mut *const ::std::os::raw::c_char,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a Double with the provided value.\n\n \\param value A double.\n\n \\return The Double object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewDouble(value: f64) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the value of a Double\n\n \\param double_obj A Double\n \\param value Returns the value of the Double.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_DoubleValue(double_obj: Dart_Handle, value: *mut f64) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a closure of static function 'function_name' in the class 'class_name'\n in the exported namespace of specified 'library'.\n\n \\param library Library object\n \\param cls_type Type object representing a Class\n \\param function_name Name of the static function in the class\n\n \\return A valid Dart instance if no error occurs during the operation."]
    pub fn Dart_GetStaticMethodClosure(
        library: Dart_Handle,
        cls_type: Dart_Handle,
        function_name: Dart_Handle,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns the True object.\n\n Requires there to be a current isolate.\n\n \\return A handle to the True object."]
    pub fn Dart_True() -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns the False object.\n\n Requires there to be a current isolate.\n\n \\return A handle to the False object."]
    pub fn Dart_False() -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a Boolean with the provided value.\n\n \\param value true or false.\n\n \\return The Boolean object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewBoolean(value: bool) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the value of a Boolean\n\n \\param boolean_obj A Boolean\n \\param value Returns the value of the Boolean.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_BooleanValue(boolean_obj: Dart_Handle, value: *mut bool) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the length of a String.\n\n \\param str A String.\n \\param length Returns the length of the String.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_StringLength(str_: Dart_Handle, length: *mut isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a String built from the provided C string\n (There is an implicit assumption that the C string passed in contains\n  UTF-8 encoded characters and '\\0' is considered as a termination\n  character).\n\n \\param value A C String\n\n \\return The String object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewStringFromCString(str_: *const ::std::os::raw::c_char) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a String built from an array of UTF-8 encoded characters.\n\n \\param utf8_array An array of UTF-8 encoded characters.\n \\param length The length of the codepoints array.\n\n \\return The String object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewStringFromUTF8(utf8_array: *const u8, length: isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a String built from an array of UTF-16 encoded characters.\n\n \\param utf16_array An array of UTF-16 encoded characters.\n \\param length The length of the codepoints array.\n\n \\return The String object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewStringFromUTF16(utf16_array: *const u16, length: isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a String built from an array of UTF-32 encoded characters.\n\n \\param utf32_array An array of UTF-32 encoded characters.\n \\param length The length of the codepoints array.\n\n \\return The String object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewStringFromUTF32(utf32_array: *const i32, length: isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a String which references an external array of\n Latin-1 (ISO-8859-1) encoded characters.\n\n \\param latin1_array Array of Latin-1 encoded characters. This must not move.\n \\param length The length of the characters array.\n \\param peer An external pointer to associate with this string.\n \\param external_allocation_size The number of externally allocated\n   bytes for peer. Used to inform the garbage collector.\n \\param callback A callback to be called when this string is finalized.\n\n \\return The String object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewExternalLatin1String(
        latin1_array: *const u8,
        length: isize,
        peer: *mut ::std::os::raw::c_void,
        external_allocation_size: isize,
        callback: Dart_HandleFinalizer,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a String which references an external array of UTF-16 encoded\n characters.\n\n \\param utf16_array An array of UTF-16 encoded characters. This must not move.\n \\param length The length of the characters array.\n \\param peer An external pointer to associate with this string.\n \\param external_allocation_size The number of externally allocated\n   bytes for peer. Used to inform the garbage collector.\n \\param callback A callback to be called when this string is finalized.\n\n \\return The String object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewExternalUTF16String(
        utf16_array: *const u16,
        length: isize,
        peer: *mut ::std::os::raw::c_void,
        external_allocation_size: isize,
        callback: Dart_HandleFinalizer,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the C string representation of a String.\n (It is a sequence of UTF-8 encoded values with a '\\0' termination.)\n\n \\param str A string.\n \\param cstr Returns the String represented as a C string.\n   This C string is scope allocated and is only valid until\n   the next call to Dart_ExitScope.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_StringToCString(
        str_: Dart_Handle,
        cstr: *mut *const ::std::os::raw::c_char,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets a UTF-8 encoded representation of a String.\n\n Any unpaired surrogate code points in the string will be converted as\n replacement characters (U+FFFD, 0xEF 0xBF 0xBD in UTF-8). If you need\n to preserve unpaired surrogates, use the Dart_StringToUTF16 function.\n\n \\param str A string.\n \\param utf8_array Returns the String represented as UTF-8 code\n   units.  This UTF-8 array is scope allocated and is only valid\n   until the next call to Dart_ExitScope.\n \\param length Used to return the length of the array which was\n   actually used.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_StringToUTF8(
        str_: Dart_Handle,
        utf8_array: *mut *mut u8,
        length: *mut isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the data corresponding to the string object. This function returns\n the data only for Latin-1 (ISO-8859-1) string objects. For all other\n string objects it returns an error.\n\n \\param str A string.\n \\param latin1_array An array allocated by the caller, used to return\n   the string data.\n \\param length Used to pass in the length of the provided array.\n   Used to return the length of the array which was actually used.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_StringToLatin1(
        str_: Dart_Handle,
        latin1_array: *mut u8,
        length: *mut isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the UTF-16 encoded representation of a string.\n\n \\param str A string.\n \\param utf16_array An array allocated by the caller, used to return\n   the array of UTF-16 encoded characters.\n \\param length Used to pass in the length of the provided array.\n   Used to return the length of the array which was actually used.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_StringToUTF16(
        str_: Dart_Handle,
        utf16_array: *mut u16,
        length: *mut isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the storage size in bytes of a String.\n\n \\param str A String.\n \\param length Returns the storage size in bytes of the String.\n  This is the size in bytes needed to store the String.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_StringStorageSize(str_: Dart_Handle, size: *mut isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Retrieves some properties associated with a String.\n Properties retrieved are:\n - character size of the string (one or two byte)\n - length of the string\n - peer pointer of string if it is an external string.\n \\param str A String.\n \\param char_size Returns the character size of the String.\n \\param str_len Returns the length of the String.\n \\param peer Returns the peer pointer associated with the String or 0 if\n   there is no peer pointer for it.\n \\return Success if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_StringGetProperties(
        str_: Dart_Handle,
        char_size: *mut isize,
        str_len: *mut isize,
        peer: *mut *mut ::std::os::raw::c_void,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a List<dynamic> of the desired length.\n\n \\param length The length of the list.\n\n \\return The List object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewList(length: isize) -> Dart_Handle;
}
pub const Dart_CoreType_Dynamic: Dart_CoreType_Id = 0;
pub const Dart_CoreType_Int: Dart_CoreType_Id = 1;
pub const Dart_CoreType_String: Dart_CoreType_Id = 2;
pub type Dart_CoreType_Id = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Returns a List of the desired length with the desired legacy element type.\n\n \\param element_type_id The type of elements of the list.\n \\param length The length of the list.\n\n \\return The List object if no error occurs. Otherwise returns an error\n handle."]
    pub fn Dart_NewListOf(element_type_id: Dart_CoreType_Id, length: isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a List of the desired length with the desired element type.\n\n \\param element_type Handle to a nullable type object. E.g., from\n Dart_GetType or Dart_GetNullableType.\n\n \\param length The length of the list.\n\n \\return The List object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewListOfType(element_type: Dart_Handle, length: isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a List of the desired length with the desired element type, filled\n with the provided object.\n\n \\param element_type Handle to a type object. E.g., from Dart_GetType.\n\n \\param fill_object Handle to an object of type 'element_type' that will be\n used to populate the list. This parameter can only be Dart_Null() if the\n length of the list is 0 or 'element_type' is a nullable type.\n\n \\param length The length of the list.\n\n \\return The List object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewListOfTypeFilled(
        element_type: Dart_Handle,
        fill_object: Dart_Handle,
        length: isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the length of a List.\n\n May generate an unhandled exception error.\n\n \\param list A List.\n \\param length Returns the length of the List.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_ListLength(list: Dart_Handle, length: *mut isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the Object at some index of a List.\n\n If the index is out of bounds, an error occurs.\n\n May generate an unhandled exception error.\n\n \\param list A List.\n \\param index A valid index into the List.\n\n \\return The Object in the List at the specified index if no error\n   occurs. Otherwise returns an error handle."]
    pub fn Dart_ListGetAt(list: Dart_Handle, index: isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets a range of Objects from a List.\n\n If any of the requested index values are out of bounds, an error occurs.\n\n May generate an unhandled exception error.\n\n \\param list A List.\n \\param offset The offset of the first item to get.\n \\param length The number of items to get.\n \\param result A pointer to fill with the objects.\n\n \\return Success if no error occurs during the operation."]
    pub fn Dart_ListGetRange(
        list: Dart_Handle,
        offset: isize,
        length: isize,
        result: *mut Dart_Handle,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Sets the Object at some index of a List.\n\n If the index is out of bounds, an error occurs.\n\n May generate an unhandled exception error.\n\n \\param array A List.\n \\param index A valid index into the List.\n \\param value The Object to put in the List.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_ListSetAt(list: Dart_Handle, index: isize, value: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " May generate an unhandled exception error."]
    pub fn Dart_ListGetAsBytes(
        list: Dart_Handle,
        offset: isize,
        native_array: *mut u8,
        length: isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " May generate an unhandled exception error."]
    pub fn Dart_ListSetAsBytes(
        list: Dart_Handle,
        offset: isize,
        native_array: *const u8,
        length: isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the Object at some key of a Map.\n\n May generate an unhandled exception error.\n\n \\param map A Map.\n \\param key An Object.\n\n \\return The value in the map at the specified key, null if the map does not\n   contain the key, or an error handle."]
    pub fn Dart_MapGetAt(map: Dart_Handle, key: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns whether the Map contains a given key.\n\n May generate an unhandled exception error.\n\n \\param map A Map.\n\n \\return A handle on a boolean indicating whether map contains the key.\n   Otherwise returns an error handle."]
    pub fn Dart_MapContainsKey(map: Dart_Handle, key: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the list of keys of a Map.\n\n May generate an unhandled exception error.\n\n \\param map A Map.\n\n \\return The list of key Objects if no error occurs. Otherwise returns an\n   error handle."]
    pub fn Dart_MapKeys(map: Dart_Handle) -> Dart_Handle;
}
pub const Dart_TypedData_kByteData: Dart_TypedData_Type = 0;
pub const Dart_TypedData_kInt8: Dart_TypedData_Type = 1;
pub const Dart_TypedData_kUint8: Dart_TypedData_Type = 2;
pub const Dart_TypedData_kUint8Clamped: Dart_TypedData_Type = 3;
pub const Dart_TypedData_kInt16: Dart_TypedData_Type = 4;
pub const Dart_TypedData_kUint16: Dart_TypedData_Type = 5;
pub const Dart_TypedData_kInt32: Dart_TypedData_Type = 6;
pub const Dart_TypedData_kUint32: Dart_TypedData_Type = 7;
pub const Dart_TypedData_kInt64: Dart_TypedData_Type = 8;
pub const Dart_TypedData_kUint64: Dart_TypedData_Type = 9;
pub const Dart_TypedData_kFloat32: Dart_TypedData_Type = 10;
pub const Dart_TypedData_kFloat64: Dart_TypedData_Type = 11;
pub const Dart_TypedData_kInt32x4: Dart_TypedData_Type = 12;
pub const Dart_TypedData_kFloat32x4: Dart_TypedData_Type = 13;
pub const Dart_TypedData_kFloat64x2: Dart_TypedData_Type = 14;
pub const Dart_TypedData_kInvalid: Dart_TypedData_Type = 15;
pub type Dart_TypedData_Type = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Return type if this object is a TypedData object.\n\n \\return kInvalid if the object is not a TypedData object or the appropriate\n   Dart_TypedData_Type."]
    pub fn Dart_GetTypeOfTypedData(object: Dart_Handle) -> Dart_TypedData_Type;
}
unsafe extern "C" {
    #[doc = " Return type if this object is an external TypedData object.\n\n \\return kInvalid if the object is not an external TypedData object or\n   the appropriate Dart_TypedData_Type."]
    pub fn Dart_GetTypeOfExternalTypedData(object: Dart_Handle) -> Dart_TypedData_Type;
}
unsafe extern "C" {
    #[doc = " Returns a TypedData object of the desired length and type.\n\n \\param type The type of the TypedData object.\n \\param length The length of the TypedData object (length in type units).\n\n \\return The TypedData object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewTypedData(type_: Dart_TypedData_Type, length: isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a TypedData object which references an external data array.\n\n \\param type The type of the data array.\n \\param data A data array. This array must not move.\n \\param length The length of the data array (length in type units).\n\n \\return The TypedData object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewExternalTypedData(
        type_: Dart_TypedData_Type,
        data: *mut ::std::os::raw::c_void,
        length: isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a TypedData object which references an external data array.\n\n \\param type The type of the data array.\n \\param data A data array. This array must not move.\n \\param length The length of the data array (length in type units).\n \\param peer A pointer to a native object or NULL.  This value is\n   provided to callback when it is invoked.\n \\param external_allocation_size The number of externally allocated\n   bytes for peer. Used to inform the garbage collector.\n \\param callback A function pointer that will be invoked sometime\n   after the object is garbage collected, unless the handle has been deleted.\n   A valid callback needs to be specified it cannot be NULL.\n\n \\return The TypedData object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewExternalTypedDataWithFinalizer(
        type_: Dart_TypedData_Type,
        data: *mut ::std::os::raw::c_void,
        length: isize,
        peer: *mut ::std::os::raw::c_void,
        external_allocation_size: isize,
        callback: Dart_HandleFinalizer,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a ByteBuffer object for the typed data.\n\n \\param type_data The TypedData object.\n\n \\return The ByteBuffer object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewByteBuffer(typed_data: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Acquires access to the internal data address of a TypedData object.\n\n \\param object The typed data object whose internal data address is to\n    be accessed.\n \\param type The type of the object is returned here.\n \\param data The internal data address is returned here.\n \\param len Size of the typed array is returned here.\n\n Notes:\n   When the internal address of the object is acquired any calls to a\n   Dart API function that could potentially allocate an object or run\n   any Dart code will return an error.\n\n   Any Dart API functions for accessing the data should not be called\n   before the corresponding release. In particular, the object should\n   not be acquired again before its release. This leads to undefined\n   behavior.\n\n \\return Success if the internal data address is acquired successfully.\n   Otherwise, returns an error handle."]
    pub fn Dart_TypedDataAcquireData(
        object: Dart_Handle,
        type_: *mut Dart_TypedData_Type,
        data: *mut *mut ::std::os::raw::c_void,
        len: *mut isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Releases access to the internal data address that was acquired earlier using\n Dart_TypedDataAcquireData.\n\n \\param object The typed data object whose internal data address is to be\n   released.\n\n \\return Success if the internal data address is released successfully.\n   Otherwise, returns an error handle."]
    pub fn Dart_TypedDataReleaseData(object: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns the TypedData object associated with the ByteBuffer object.\n\n \\param byte_buffer The ByteBuffer object.\n\n \\return The TypedData object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_GetDataFromByteBuffer(byte_buffer: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Invokes a constructor, creating a new object.\n\n This function allows hidden constructors (constructors with leading\n underscores) to be called.\n\n \\param type Type of object to be constructed.\n \\param constructor_name The name of the constructor to invoke.  Use\n   Dart_Null() or Dart_EmptyString() to invoke the unnamed constructor.\n   This name should not include the name of the class.\n \\param number_of_arguments Size of the arguments array.\n \\param arguments An array of arguments to the constructor.\n\n \\return If the constructor is called and completes successfully,\n   then the new object. If an error occurs during execution, then an\n   error handle is returned."]
    pub fn Dart_New(
        type_: Dart_Handle,
        constructor_name: Dart_Handle,
        number_of_arguments: ::std::os::raw::c_int,
        arguments: *mut Dart_Handle,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Allocate a new object without invoking a constructor.\n\n \\param type The type of an object to be allocated.\n\n \\return The new object. If an error occurs during execution, then an\n   error handle is returned."]
    pub fn Dart_Allocate(type_: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Allocate a new object without invoking a constructor, and sets specified\n  native fields.\n\n \\param type The type of an object to be allocated.\n \\param num_native_fields The number of native fields to set.\n \\param native_fields An array containing the value of native fields.\n\n \\return The new object. If an error occurs during execution, then an\n   error handle is returned."]
    pub fn Dart_AllocateWithNativeFields(
        type_: Dart_Handle,
        num_native_fields: isize,
        native_fields: *const isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Invokes a method or function.\n\n The 'target' parameter may be an object, type, or library.  If\n 'target' is an object, then this function will invoke an instance\n method.  If 'target' is a type, then this function will invoke a\n static method.  If 'target' is a library, then this function will\n invoke a top-level function from that library.\n NOTE: This API call cannot be used to invoke methods of a type object.\n\n This function ignores visibility (leading underscores in names).\n\n May generate an unhandled exception error.\n\n \\param target An object, type, or library.\n \\param name The name of the function or method to invoke.\n \\param number_of_arguments Size of the arguments array.\n \\param arguments An array of arguments to the function.\n\n \\return If the function or method is called and completes\n   successfully, then the return value is returned. If an error\n   occurs during execution, then an error handle is returned."]
    pub fn Dart_Invoke(
        target: Dart_Handle,
        name: Dart_Handle,
        number_of_arguments: ::std::os::raw::c_int,
        arguments: *mut Dart_Handle,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Invokes a Closure with the given arguments.\n\n May generate an unhandled exception error.\n\n \\return If no error occurs during execution, then the result of\n   invoking the closure is returned. If an error occurs during\n   execution, then an error handle is returned."]
    pub fn Dart_InvokeClosure(
        closure: Dart_Handle,
        number_of_arguments: ::std::os::raw::c_int,
        arguments: *mut Dart_Handle,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Invokes a Generative Constructor on an object that was previously\n allocated using Dart_Allocate/Dart_AllocateWithNativeFields.\n\n The 'target' parameter must be an object.\n\n This function ignores visibility (leading underscores in names).\n\n May generate an unhandled exception error.\n\n \\param target An object.\n \\param name The name of the constructor to invoke.\n   Use Dart_Null() or Dart_EmptyString() to invoke the unnamed constructor.\n \\param number_of_arguments Size of the arguments array.\n \\param arguments An array of arguments to the function.\n\n \\return If the constructor is called and completes\n   successfully, then the object is returned. If an error\n   occurs during execution, then an error handle is returned."]
    pub fn Dart_InvokeConstructor(
        object: Dart_Handle,
        name: Dart_Handle,
        number_of_arguments: ::std::os::raw::c_int,
        arguments: *mut Dart_Handle,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the value of a field.\n\n The 'container' parameter may be an object, type, or library.  If\n 'container' is an object, then this function will access an\n instance field.  If 'container' is a type, then this function will\n access a static field.  If 'container' is a library, then this\n function will access a top-level variable.\n NOTE: This API call cannot be used to access fields of a type object.\n\n This function ignores field visibility (leading underscores in names).\n\n May generate an unhandled exception error.\n\n \\param container An object, type, or library.\n \\param name A field name.\n\n \\return If no error occurs, then the value of the field is\n   returned. Otherwise an error handle is returned."]
    pub fn Dart_GetField(container: Dart_Handle, name: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Sets the value of a field.\n\n The 'container' parameter may actually be an object, type, or\n library.  If 'container' is an object, then this function will\n access an instance field.  If 'container' is a type, then this\n function will access a static field.  If 'container' is a library,\n then this function will access a top-level variable.\n NOTE: This API call cannot be used to access fields of a type object.\n\n This function ignores field visibility (leading underscores in names).\n\n May generate an unhandled exception error.\n\n \\param container An object, type, or library.\n \\param name A field name.\n \\param value The new field value.\n\n \\return A valid handle if no error occurs."]
    pub fn Dart_SetField(
        container: Dart_Handle,
        name: Dart_Handle,
        value: Dart_Handle,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Throws an exception.\n\n This function causes a Dart language exception to be thrown. This\n will proceed in the standard way, walking up Dart frames until an\n appropriate 'catch' block is found, executing 'finally' blocks,\n etc.\n\n If an error handle is passed into this function, the error is\n propagated immediately.  See Dart_PropagateError for a discussion\n of error propagation.\n\n If successful, this function does not return. Note that this means\n that the destructors of any stack-allocated C++ objects will not be\n called. If there are no Dart frames on the stack, an error occurs.\n\n \\return An error handle if the exception was not thrown.\n   Otherwise the function does not return."]
    pub fn Dart_ThrowException(exception: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Rethrows an exception.\n\n Rethrows an exception, unwinding all dart frames on the stack. If\n successful, this function does not return. Note that this means\n that the destructors of any stack-allocated C++ objects will not be\n called. If there are no Dart frames on the stack, an error occurs.\n\n \\return An error handle if the exception was not thrown.\n   Otherwise the function does not return."]
    pub fn Dart_ReThrowException(exception: Dart_Handle, stacktrace: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the number of native instance fields in an object."]
    pub fn Dart_GetNativeInstanceFieldCount(
        obj: Dart_Handle,
        count: *mut ::std::os::raw::c_int,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the value of a native field.\n\n TODO(turnidge): Document."]
    pub fn Dart_GetNativeInstanceField(
        obj: Dart_Handle,
        index: ::std::os::raw::c_int,
        value: *mut isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Sets the value of a native field.\n\n TODO(turnidge): Document."]
    pub fn Dart_SetNativeInstanceField(
        obj: Dart_Handle,
        index: ::std::os::raw::c_int,
        value: isize,
    ) -> Dart_Handle;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_NativeArguments {
    _unused: [u8; 0],
}
#[doc = " The arguments to a native function.\n\n This object is passed to a native function to represent its\n arguments and return value. It allows access to the arguments to a\n native function by index. It also allows the return value of a\n native function to be set."]
pub type Dart_NativeArguments = *mut _Dart_NativeArguments;
unsafe extern "C" {
    #[doc = " Extracts current isolate group data from the native arguments structure."]
    pub fn Dart_GetNativeIsolateGroupData(
        args: Dart_NativeArguments,
    ) -> *mut ::std::os::raw::c_void;
}
pub const Dart_NativeArgument_kBool: Dart_NativeArgument_Type = 0;
pub const Dart_NativeArgument_kInt32: Dart_NativeArgument_Type = 1;
pub const Dart_NativeArgument_kUint32: Dart_NativeArgument_Type = 2;
pub const Dart_NativeArgument_kInt64: Dart_NativeArgument_Type = 3;
pub const Dart_NativeArgument_kUint64: Dart_NativeArgument_Type = 4;
pub const Dart_NativeArgument_kDouble: Dart_NativeArgument_Type = 5;
pub const Dart_NativeArgument_kString: Dart_NativeArgument_Type = 6;
pub const Dart_NativeArgument_kInstance: Dart_NativeArgument_Type = 7;
pub const Dart_NativeArgument_kNativeFields: Dart_NativeArgument_Type = 8;
pub type Dart_NativeArgument_Type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_NativeArgument_Descriptor {
    pub type_: u8,
    pub index: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _Dart_NativeArgument_Descriptor"]
        [::std::mem::size_of::<_Dart_NativeArgument_Descriptor>() - 2usize];
    ["Alignment of _Dart_NativeArgument_Descriptor"]
        [::std::mem::align_of::<_Dart_NativeArgument_Descriptor>() - 1usize];
    ["Offset of field: _Dart_NativeArgument_Descriptor::type_"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Descriptor, type_) - 0usize];
    ["Offset of field: _Dart_NativeArgument_Descriptor::index"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Descriptor, index) - 1usize];
};
pub type Dart_NativeArgument_Descriptor = _Dart_NativeArgument_Descriptor;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _Dart_NativeArgument_Value {
    pub as_bool: bool,
    pub as_int32: i32,
    pub as_uint32: u32,
    pub as_int64: i64,
    pub as_uint64: u64,
    pub as_double: f64,
    pub as_string: _Dart_NativeArgument_Value__bindgen_ty_1,
    pub as_native_fields: _Dart_NativeArgument_Value__bindgen_ty_2,
    pub as_instance: Dart_Handle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_NativeArgument_Value__bindgen_ty_1 {
    pub dart_str: Dart_Handle,
    pub peer: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _Dart_NativeArgument_Value__bindgen_ty_1"]
        [::std::mem::size_of::<_Dart_NativeArgument_Value__bindgen_ty_1>() - 16usize];
    ["Alignment of _Dart_NativeArgument_Value__bindgen_ty_1"]
        [::std::mem::align_of::<_Dart_NativeArgument_Value__bindgen_ty_1>() - 8usize];
    ["Offset of field: _Dart_NativeArgument_Value__bindgen_ty_1::dart_str"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Value__bindgen_ty_1, dart_str) - 0usize];
    ["Offset of field: _Dart_NativeArgument_Value__bindgen_ty_1::peer"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Value__bindgen_ty_1, peer) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_NativeArgument_Value__bindgen_ty_2 {
    pub num_fields: isize,
    pub values: *mut isize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _Dart_NativeArgument_Value__bindgen_ty_2"]
        [::std::mem::size_of::<_Dart_NativeArgument_Value__bindgen_ty_2>() - 16usize];
    ["Alignment of _Dart_NativeArgument_Value__bindgen_ty_2"]
        [::std::mem::align_of::<_Dart_NativeArgument_Value__bindgen_ty_2>() - 8usize];
    ["Offset of field: _Dart_NativeArgument_Value__bindgen_ty_2::num_fields"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Value__bindgen_ty_2, num_fields) - 0usize];
    ["Offset of field: _Dart_NativeArgument_Value__bindgen_ty_2::values"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Value__bindgen_ty_2, values) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _Dart_NativeArgument_Value"]
        [::std::mem::size_of::<_Dart_NativeArgument_Value>() - 16usize];
    ["Alignment of _Dart_NativeArgument_Value"]
        [::std::mem::align_of::<_Dart_NativeArgument_Value>() - 8usize];
    ["Offset of field: _Dart_NativeArgument_Value::as_bool"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Value, as_bool) - 0usize];
    ["Offset of field: _Dart_NativeArgument_Value::as_int32"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Value, as_int32) - 0usize];
    ["Offset of field: _Dart_NativeArgument_Value::as_uint32"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Value, as_uint32) - 0usize];
    ["Offset of field: _Dart_NativeArgument_Value::as_int64"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Value, as_int64) - 0usize];
    ["Offset of field: _Dart_NativeArgument_Value::as_uint64"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Value, as_uint64) - 0usize];
    ["Offset of field: _Dart_NativeArgument_Value::as_double"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Value, as_double) - 0usize];
    ["Offset of field: _Dart_NativeArgument_Value::as_string"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Value, as_string) - 0usize];
    ["Offset of field: _Dart_NativeArgument_Value::as_native_fields"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Value, as_native_fields) - 0usize];
    ["Offset of field: _Dart_NativeArgument_Value::as_instance"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Value, as_instance) - 0usize];
};
pub type Dart_NativeArgument_Value = _Dart_NativeArgument_Value;
pub const kNativeArgNumberPos: _bindgen_ty_1 = 0;
pub const kNativeArgNumberSize: _bindgen_ty_1 = 8;
pub const kNativeArgTypePos: _bindgen_ty_1 = 8;
pub const kNativeArgTypeSize: _bindgen_ty_1 = 8;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Gets the native arguments based on the types passed in and populates\n the passed arguments buffer with appropriate native values.\n\n \\param args the Native arguments block passed into the native call.\n \\param num_arguments length of argument descriptor array and argument\n   values array passed in.\n \\param arg_descriptors an array that describes the arguments that\n   need to be retrieved. For each argument to be retrieved the descriptor\n   contains the argument number (0, 1 etc.) and the argument type\n   described using Dart_NativeArgument_Type, e.g:\n   DART_NATIVE_ARG_DESCRIPTOR(Dart_NativeArgument_kBool, 1) indicates\n   that the first argument is to be retrieved and it should be a boolean.\n \\param arg_values array into which the native arguments need to be\n   extracted into, the array is allocated by the caller (it could be\n   stack allocated to avoid the malloc/free performance overhead).\n\n \\return Success if all the arguments could be extracted correctly,\n   returns an error handle if there were any errors while extracting the\n   arguments (mismatched number of arguments, incorrect types, etc.)."]
    pub fn Dart_GetNativeArguments(
        args: Dart_NativeArguments,
        num_arguments: ::std::os::raw::c_int,
        arg_descriptors: *const Dart_NativeArgument_Descriptor,
        arg_values: *mut Dart_NativeArgument_Value,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the native argument at some index."]
    pub fn Dart_GetNativeArgument(
        args: Dart_NativeArguments,
        index: ::std::os::raw::c_int,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the number of native arguments."]
    pub fn Dart_GetNativeArgumentCount(args: Dart_NativeArguments) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Gets all the native fields of the native argument at some index.\n \\param args Native arguments structure.\n \\param arg_index Index of the desired argument in the structure above.\n \\param num_fields size of the intptr_t array 'field_values' passed in.\n \\param field_values intptr_t array in which native field values are returned.\n \\return Success if the native fields where copied in successfully. Otherwise\n   returns an error handle. On success the native field values are copied\n   into the 'field_values' array, if the argument at 'arg_index' is a\n   null object then 0 is copied as the native field values into the\n   'field_values' array."]
    pub fn Dart_GetNativeFieldsOfArgument(
        args: Dart_NativeArguments,
        arg_index: ::std::os::raw::c_int,
        num_fields: ::std::os::raw::c_int,
        field_values: *mut isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the native field of the receiver."]
    pub fn Dart_GetNativeReceiver(args: Dart_NativeArguments, value: *mut isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets a string native argument at some index.\n \\param args Native arguments structure.\n \\param arg_index Index of the desired argument in the structure above.\n \\param peer Returns the peer pointer if the string argument has one.\n \\return Success if the string argument has a peer, if it does not\n   have a peer then the String object is returned. Otherwise returns\n   an error handle (argument is not a String object)."]
    pub fn Dart_GetNativeStringArgument(
        args: Dart_NativeArguments,
        arg_index: ::std::os::raw::c_int,
        peer: *mut *mut ::std::os::raw::c_void,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets an integer native argument at some index.\n \\param args Native arguments structure.\n \\param arg_index Index of the desired argument in the structure above.\n \\param value Returns the integer value if the argument is an Integer.\n \\return Success if no error occurs. Otherwise returns an error handle."]
    pub fn Dart_GetNativeIntegerArgument(
        args: Dart_NativeArguments,
        index: ::std::os::raw::c_int,
        value: *mut i64,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets a boolean native argument at some index.\n \\param args Native arguments structure.\n \\param arg_index Index of the desired argument in the structure above.\n \\param value Returns the boolean value if the argument is a Boolean.\n \\return Success if no error occurs. Otherwise returns an error handle."]
    pub fn Dart_GetNativeBooleanArgument(
        args: Dart_NativeArguments,
        index: ::std::os::raw::c_int,
        value: *mut bool,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets a double native argument at some index.\n \\param args Native arguments structure.\n \\param arg_index Index of the desired argument in the structure above.\n \\param value Returns the double value if the argument is a double.\n \\return Success if no error occurs. Otherwise returns an error handle."]
    pub fn Dart_GetNativeDoubleArgument(
        args: Dart_NativeArguments,
        index: ::std::os::raw::c_int,
        value: *mut f64,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Sets the return value for a native function.\n\n If retval is an Error handle, then error will be propagated once\n the native functions exits. See Dart_PropagateError for a\n discussion of how different types of errors are propagated."]
    pub fn Dart_SetReturnValue(args: Dart_NativeArguments, retval: Dart_Handle);
}
unsafe extern "C" {
    pub fn Dart_SetWeakHandleReturnValue(
        args: Dart_NativeArguments,
        rval: Dart_WeakPersistentHandle,
    );
}
unsafe extern "C" {
    pub fn Dart_SetBooleanReturnValue(args: Dart_NativeArguments, retval: bool);
}
unsafe extern "C" {
    pub fn Dart_SetIntegerReturnValue(args: Dart_NativeArguments, retval: i64);
}
unsafe extern "C" {
    pub fn Dart_SetDoubleReturnValue(args: Dart_NativeArguments, retval: f64);
}
#[doc = " A native function."]
pub type Dart_NativeFunction =
    ::std::option::Option<unsafe extern "C" fn(arguments: Dart_NativeArguments)>;
#[doc = " Native entry resolution callback.\n\n For libraries and scripts which have native functions, the embedder\n can provide a native entry resolver. This callback is used to map a\n name/arity to a Dart_NativeFunction. If no function is found, the\n callback should return NULL.\n\n The parameters to the native resolver function are:\n \\param name a Dart string which is the name of the native function.\n \\param num_of_arguments is the number of arguments expected by the\n   native function.\n \\param auto_setup_scope is a boolean flag that can be set by the resolver\n   to indicate if this function needs a Dart API scope (see Dart_EnterScope/\n   Dart_ExitScope) to be setup automatically by the VM before calling into\n   the native function. By default most native functions would require this\n   to be true but some light weight native functions which do not call back\n   into the VM through the Dart API may not require a Dart scope to be\n   setup automatically.\n\n \\return A valid Dart_NativeFunction which resolves to a native entry point\n   for the native function.\n\n See Dart_SetNativeResolver."]
pub type Dart_NativeEntryResolver = ::std::option::Option<
    unsafe extern "C" fn(
        name: Dart_Handle,
        num_of_arguments: ::std::os::raw::c_int,
        auto_setup_scope: *mut bool,
    ) -> Dart_NativeFunction,
>;
#[doc = " Native entry symbol lookup callback.\n\n For libraries and scripts which have native functions, the embedder\n can provide a callback for mapping a native entry to a symbol. This callback\n maps a native function entry PC to the native function name. If no native\n entry symbol can be found, the callback should return NULL.\n\n The parameters to the native reverse resolver function are:\n \\param nf A Dart_NativeFunction.\n\n \\return A const UTF-8 string containing the symbol name or NULL.\n\n See Dart_SetNativeResolver."]
pub type Dart_NativeEntrySymbol =
    ::std::option::Option<unsafe extern "C" fn(nf: Dart_NativeFunction) -> *const u8>;
#[doc = " An environment lookup callback function.\n\n \\param name The name of the value to lookup in the environment.\n\n \\return A valid handle to a string if the name exists in the\n current environment or Dart_Null() if not."]
pub type Dart_EnvironmentCallback =
    ::std::option::Option<unsafe extern "C" fn(name: Dart_Handle) -> Dart_Handle>;
unsafe extern "C" {
    #[doc = " Sets the environment callback for the current isolate. This\n callback is used to lookup environment values by name in the\n current environment. This enables the embedder to supply values for\n the const constructors bool.fromEnvironment, int.fromEnvironment\n and String.fromEnvironment."]
    pub fn Dart_SetEnvironmentCallback(callback: Dart_EnvironmentCallback) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Sets the callback used to resolve native functions for a library.\n\n \\param library A library.\n \\param resolver A native entry resolver.\n\n \\return A valid handle if the native resolver was set successfully."]
    pub fn Dart_SetNativeResolver(
        library: Dart_Handle,
        resolver: Dart_NativeEntryResolver,
        symbol: Dart_NativeEntrySymbol,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns the callback used to resolve native functions for a library.\n\n \\param library A library.\n \\param resolver a pointer to a Dart_NativeEntryResolver\n\n \\return A valid handle if the library was found."]
    pub fn Dart_GetNativeResolver(
        library: Dart_Handle,
        resolver: *mut Dart_NativeEntryResolver,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns the callback used to resolve native function symbols for a library.\n\n \\param library A library.\n \\param resolver a pointer to a Dart_NativeEntrySymbol.\n\n \\return A valid handle if the library was found."]
    pub fn Dart_GetNativeSymbol(
        library: Dart_Handle,
        resolver: *mut Dart_NativeEntrySymbol,
    ) -> Dart_Handle;
}
pub const Dart_kCanonicalizeUrl: Dart_LibraryTag = 0;
pub const Dart_kImportTag: Dart_LibraryTag = 1;
pub const Dart_kKernelTag: Dart_LibraryTag = 2;
pub const Dart_kImportExtensionTag: Dart_LibraryTag = 3;
pub type Dart_LibraryTag = ::std::os::raw::c_uint;
#[doc = " The library tag handler is a multi-purpose callback provided by the\n embedder to the Dart VM. The embedder implements the tag handler to\n provide the ability to load Dart scripts and imports.\n\n -- TAGS --\n\n Dart_kCanonicalizeUrl\n\n This tag indicates that the embedder should canonicalize 'url' with\n respect to 'library'.  For most embedders, the\n Dart_DefaultCanonicalizeUrl function is a sufficient implementation\n of this tag.  The return value should be a string holding the\n canonicalized url.\n\n Dart_kImportTag\n\n This tag is used to load a library from IsolateMirror.loadUri. The embedder\n should call Dart_LoadLibraryFromKernel to provide the library to the VM. The\n return value should be an error or library (the result from\n Dart_LoadLibraryFromKernel).\n\n Dart_kKernelTag\n\n This tag is used to load the intermediate file (kernel) generated by\n the Dart front end. This tag is typically used when a 'hot-reload'\n of an application is needed and the VM is 'use dart front end' mode.\n The dart front end typically compiles all the scripts, imports and part\n files into one intermediate file hence we don't use the source/import or\n script tags. The return value should be an error or a TypedData containing\n the kernel bytes.\n\n Dart_kImportExtensionTag\n\n This tag is used to load an external import (shared object file). The\n extension path must have the scheme 'dart-ext:'."]
pub type Dart_LibraryTagHandler = ::std::option::Option<
    unsafe extern "C" fn(
        tag: Dart_LibraryTag,
        library_or_package_map_url: Dart_Handle,
        url: Dart_Handle,
    ) -> Dart_Handle,
>;
unsafe extern "C" {
    #[doc = " Sets library tag handler for the current isolate. This handler is\n used to handle the various tags encountered while loading libraries\n or scripts in the isolate.\n\n \\param handler Handler code to be used for handling the various tags\n   encountered while loading libraries or scripts in the isolate.\n\n \\return If no error occurs, the handler is set for the isolate.\n   Otherwise an error handle is returned.\n\n TODO(turnidge): Document."]
    pub fn Dart_SetLibraryTagHandler(handler: Dart_LibraryTagHandler) -> Dart_Handle;
}
#[doc = " Handles deferred loading requests. When this handler is invoked, it should\n eventually load the deferred loading unit with the given id and call\n Dart_DeferredLoadComplete or Dart_DeferredLoadCompleteError. It is\n recommended that the loading occur asynchronously, but it is permitted to\n call Dart_DeferredLoadComplete or Dart_DeferredLoadCompleteError before the\n handler returns.\n\n If an error is returned, it will be propogated through\n `prefix.loadLibrary()`. This is useful for synchronous\n implementations, which must propogate any unwind errors from\n Dart_DeferredLoadComplete or Dart_DeferredLoadComplete. Otherwise the handler\n should return a non-error such as `Dart_Null()`."]
pub type Dart_DeferredLoadHandler =
    ::std::option::Option<unsafe extern "C" fn(loading_unit_id: isize) -> Dart_Handle>;
unsafe extern "C" {
    #[doc = " Sets the deferred load handler for the current isolate. This handler is\n used to handle loading deferred imports in an AppJIT or AppAOT program."]
    pub fn Dart_SetDeferredLoadHandler(handler: Dart_DeferredLoadHandler) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Notifies the VM that a deferred load completed successfully. This function\n will eventually cause the corresponding `prefix.loadLibrary()` futures to\n complete.\n\n Requires the current isolate to be the same current isolate during the\n invocation of the Dart_DeferredLoadHandler."]
    pub fn Dart_DeferredLoadComplete(
        loading_unit_id: isize,
        snapshot_data: *const u8,
        snapshot_instructions: *const u8,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Notifies the VM that a deferred load failed. This function\n will eventually cause the corresponding `prefix.loadLibrary()` futures to\n complete with an error.\n\n If `transient` is true, future invocations of `prefix.loadLibrary()` will\n trigger new load requests. If false, futures invocation will complete with\n the same error.\n\n Requires the current isolate to be the same current isolate during the\n invocation of the Dart_DeferredLoadHandler."]
    pub fn Dart_DeferredLoadCompleteError(
        loading_unit_id: isize,
        error_message: *const ::std::os::raw::c_char,
        transient: bool,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Canonicalizes a url with respect to some library.\n\n The url is resolved with respect to the library's url and some url\n normalizations are performed.\n\n This canonicalization function should be sufficient for most\n embedders to implement the Dart_kCanonicalizeUrl tag.\n\n \\param base_url The base url relative to which the url is\n                being resolved.\n \\param url The url being resolved and canonicalized.  This\n            parameter is a string handle.\n\n \\return If no error occurs, a String object is returned.  Otherwise\n   an error handle is returned."]
    pub fn Dart_DefaultCanonicalizeUrl(base_url: Dart_Handle, url: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Loads the root library for the current isolate.\n\n Requires there to be no current root library.\n\n \\param buffer A buffer which contains a kernel binary (see\n     pkg/kernel/binary.md). Must remain valid until isolate group shutdown.\n \\param buffer_size Length of the passed in buffer.\n\n \\return A handle to the root library, or an error."]
    pub fn Dart_LoadScriptFromKernel(kernel_buffer: *const u8, kernel_size: isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the library for the root script for the current isolate.\n\n If the root script has not yet been set for the current isolate,\n this function returns Dart_Null().  This function never returns an\n error handle.\n\n \\return Returns the root Library for the current isolate or Dart_Null()."]
    pub fn Dart_RootLibrary() -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Sets the root library for the current isolate.\n\n \\return Returns an error handle if `library` is not a library handle."]
    pub fn Dart_SetRootLibrary(library: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Lookup or instantiate a legacy type by name and type arguments from a\n Library.\n\n \\param library The library containing the class or interface.\n \\param class_name The class name for the type.\n \\param number_of_type_arguments Number of type arguments.\n   For non parametric types the number of type arguments would be 0.\n \\param type_arguments Pointer to an array of type arguments.\n   For non parameteric types a NULL would be passed in for this argument.\n\n \\return If no error occurs, the type is returned.\n   Otherwise an error handle is returned."]
    pub fn Dart_GetType(
        library: Dart_Handle,
        class_name: Dart_Handle,
        number_of_type_arguments: isize,
        type_arguments: *mut Dart_Handle,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Lookup or instantiate a nullable type by name and type arguments from\n Library.\n\n \\param library The library containing the class or interface.\n \\param class_name The class name for the type.\n \\param number_of_type_arguments Number of type arguments.\n   For non parametric types the number of type arguments would be 0.\n \\param type_arguments Pointer to an array of type arguments.\n   For non parameteric types a NULL would be passed in for this argument.\n\n \\return If no error occurs, the type is returned.\n   Otherwise an error handle is returned."]
    pub fn Dart_GetNullableType(
        library: Dart_Handle,
        class_name: Dart_Handle,
        number_of_type_arguments: isize,
        type_arguments: *mut Dart_Handle,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Lookup or instantiate a non-nullable type by name and type arguments from\n Library.\n\n \\param library The library containing the class or interface.\n \\param class_name The class name for the type.\n \\param number_of_type_arguments Number of type arguments.\n   For non parametric types the number of type arguments would be 0.\n \\param type_arguments Pointer to an array of type arguments.\n   For non parameteric types a NULL would be passed in for this argument.\n\n \\return If no error occurs, the type is returned.\n   Otherwise an error handle is returned."]
    pub fn Dart_GetNonNullableType(
        library: Dart_Handle,
        class_name: Dart_Handle,
        number_of_type_arguments: isize,
        type_arguments: *mut Dart_Handle,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Creates a nullable version of the provided type.\n\n \\param type The type to be converted to a nullable type.\n\n \\return If no error occurs, a nullable type is returned.\n   Otherwise an error handle is returned."]
    pub fn Dart_TypeToNullableType(type_: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Creates a non-nullable version of the provided type.\n\n \\param type The type to be converted to a non-nullable type.\n\n \\return If no error occurs, a non-nullable type is returned.\n   Otherwise an error handle is returned."]
    pub fn Dart_TypeToNonNullableType(type_: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " A type's nullability.\n\n \\param type A Dart type.\n \\param result An out parameter containing the result of the check. True if\n the type is of the specified nullability, false otherwise.\n\n \\return Returns an error handle if type is not of type Type."]
    pub fn Dart_IsNullableType(type_: Dart_Handle, result: *mut bool) -> Dart_Handle;
}
unsafe extern "C" {
    pub fn Dart_IsNonNullableType(type_: Dart_Handle, result: *mut bool) -> Dart_Handle;
}
unsafe extern "C" {
    pub fn Dart_IsLegacyType(type_: Dart_Handle, result: *mut bool) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Lookup a class or interface by name from a Library.\n\n \\param library The library containing the class or interface.\n \\param class_name The name of the class or interface.\n\n \\return If no error occurs, the class or interface is\n   returned. Otherwise an error handle is returned."]
    pub fn Dart_GetClass(library: Dart_Handle, class_name: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns an import path to a Library, such as \"file:///test.dart\" or\n \"dart:core\"."]
    pub fn Dart_LibraryUrl(library: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a URL from which a Library was loaded."]
    pub fn Dart_LibraryResolvedUrl(library: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " \\return An array of libraries."]
    pub fn Dart_GetLoadedLibraries() -> Dart_Handle;
}
unsafe extern "C" {
    pub fn Dart_LookupLibrary(url: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Report an loading error for the library.\n\n \\param library The library that failed to load.\n \\param error The Dart error instance containing the load error.\n\n \\return If the VM handles the error, the return value is\n a null handle. If it doesn't handle the error, the error\n object is returned."]
    pub fn Dart_LibraryHandleError(library: Dart_Handle, error: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Called by the embedder to load a partial program. Does not set the root\n library.\n\n \\param buffer A buffer which contains a kernel binary (see\n     pkg/kernel/binary.md). Must remain valid until isolate shutdown.\n \\param buffer_size Length of the passed in buffer.\n\n \\return A handle to the main library of the compilation unit, or an error."]
    pub fn Dart_LoadLibraryFromKernel(
        kernel_buffer: *const u8,
        kernel_buffer_size: isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a flattened list of pairs. The first element in each pair is the\n importing library and and the second element is the imported library for each\n import in the isolate of a library whose URI's scheme is [scheme].\n\n Requires there to be a current isolate.\n\n \\return A handle to a list of flattened pairs of importer-importee."]
    pub fn Dart_GetImportsOfScheme(scheme: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Indicates that all outstanding load requests have been satisfied.\n This finalizes all the new classes loaded and optionally completes\n deferred library futures.\n\n Requires there to be a current isolate.\n\n \\param complete_futures Specify true if all deferred library\n  futures should be completed, false otherwise.\n\n \\return Success if all classes have been finalized and deferred library\n   futures are completed. Otherwise, returns an error."]
    pub fn Dart_FinalizeLoading(complete_futures: bool) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns the value of peer field of 'object' in 'peer'.\n\n \\param object An object.\n \\param peer An out parameter that returns the value of the peer\n   field.\n\n \\return Returns an error if 'object' is a subtype of Null, num, or\n   bool."]
    pub fn Dart_GetPeer(object: Dart_Handle, peer: *mut *mut ::std::os::raw::c_void)
        -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Sets the value of the peer field of 'object' to the value of\n 'peer'.\n\n \\param object An object.\n \\param peer A value to store in the peer field.\n\n \\return Returns an error if 'object' is a subtype of Null, num, or\n   bool."]
    pub fn Dart_SetPeer(object: Dart_Handle, peer: *mut ::std::os::raw::c_void) -> Dart_Handle;
}
pub const Dart_KernelCompilationStatus_Unknown: Dart_KernelCompilationStatus = -1;
pub const Dart_KernelCompilationStatus_Ok: Dart_KernelCompilationStatus = 0;
pub const Dart_KernelCompilationStatus_Error: Dart_KernelCompilationStatus = 1;
pub const Dart_KernelCompilationStatus_Crash: Dart_KernelCompilationStatus = 2;
#[doc = " Experimental support for Dart to Kernel parser isolate.\n\n TODO(hausner): Document finalized interface.\n"]
pub type Dart_KernelCompilationStatus = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_KernelCompilationResult {
    pub status: Dart_KernelCompilationStatus,
    pub null_safety: bool,
    pub error: *mut ::std::os::raw::c_char,
    pub kernel: *mut u8,
    pub kernel_size: isize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Dart_KernelCompilationResult"]
        [::std::mem::size_of::<Dart_KernelCompilationResult>() - 32usize];
    ["Alignment of Dart_KernelCompilationResult"]
        [::std::mem::align_of::<Dart_KernelCompilationResult>() - 8usize];
    ["Offset of field: Dart_KernelCompilationResult::status"]
        [::std::mem::offset_of!(Dart_KernelCompilationResult, status) - 0usize];
    ["Offset of field: Dart_KernelCompilationResult::null_safety"]
        [::std::mem::offset_of!(Dart_KernelCompilationResult, null_safety) - 4usize];
    ["Offset of field: Dart_KernelCompilationResult::error"]
        [::std::mem::offset_of!(Dart_KernelCompilationResult, error) - 8usize];
    ["Offset of field: Dart_KernelCompilationResult::kernel"]
        [::std::mem::offset_of!(Dart_KernelCompilationResult, kernel) - 16usize];
    ["Offset of field: Dart_KernelCompilationResult::kernel_size"]
        [::std::mem::offset_of!(Dart_KernelCompilationResult, kernel_size) - 24usize];
};
pub const Dart_KernelCompilationVerbosityLevel_Error: Dart_KernelCompilationVerbosityLevel = 0;
pub const Dart_KernelCompilationVerbosityLevel_Warning: Dart_KernelCompilationVerbosityLevel = 1;
pub const Dart_KernelCompilationVerbosityLevel_Info: Dart_KernelCompilationVerbosityLevel = 2;
pub const Dart_KernelCompilationVerbosityLevel_All: Dart_KernelCompilationVerbosityLevel = 3;
pub type Dart_KernelCompilationVerbosityLevel = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn Dart_IsKernelIsolate(isolate: Dart_Isolate) -> bool;
}
unsafe extern "C" {
    pub fn Dart_KernelIsolateIsRunning() -> bool;
}
unsafe extern "C" {
    pub fn Dart_KernelPort() -> Dart_Port;
}
unsafe extern "C" {
    #[doc = " Compiles the given `script_uri` to a kernel file.\n\n \\param platform_kernel A buffer containing the kernel of the platform (e.g.\n `vm_platform_strong.dill`). The VM does not take ownership of this memory.\n\n \\param platform_kernel_size The length of the platform_kernel buffer.\n\n \\param snapshot_compile Set to `true` when the compilation is for a snapshot.\n This is used by the frontend to determine if compilation related information\n should be printed to console (e.g., null safety mode).\n\n \\param verbosity Specifies the logging behavior of the kernel compilation\n service.\n\n \\return Returns the result of the compilation.\n\n On a successful compilation the returned [Dart_KernelCompilationResult] has\n a status of [Dart_KernelCompilationStatus_Ok] and the `kernel`/`kernel_size`\n fields are set. The caller takes ownership of the malloc()ed buffer.\n\n On a failed compilation the `error` might be set describing the reason for\n the failed compilation. The caller takes ownership of the malloc()ed\n error.\n\n Requires there to be a current isolate."]
    pub fn Dart_CompileToKernel(
        script_uri: *const ::std::os::raw::c_char,
        platform_kernel: *const u8,
        platform_kernel_size: isize,
        incremental_compile: bool,
        snapshot_compile: bool,
        package_config: *const ::std::os::raw::c_char,
        verbosity: Dart_KernelCompilationVerbosityLevel,
    ) -> Dart_KernelCompilationResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_SourceFile {
    pub uri: *const ::std::os::raw::c_char,
    pub source: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Dart_SourceFile"][::std::mem::size_of::<Dart_SourceFile>() - 16usize];
    ["Alignment of Dart_SourceFile"][::std::mem::align_of::<Dart_SourceFile>() - 8usize];
    ["Offset of field: Dart_SourceFile::uri"]
        [::std::mem::offset_of!(Dart_SourceFile, uri) - 0usize];
    ["Offset of field: Dart_SourceFile::source"]
        [::std::mem::offset_of!(Dart_SourceFile, source) - 8usize];
};
unsafe extern "C" {
    pub fn Dart_KernelListDependencies() -> Dart_KernelCompilationResult;
}
unsafe extern "C" {
    #[doc = " Sets the kernel buffer which will be used to load Dart SDK sources\n dynamically at runtime.\n\n \\param platform_kernel A buffer containing kernel which has sources for the\n Dart SDK populated. Note: The VM does not take ownership of this memory.\n\n \\param platform_kernel_size The length of the platform_kernel buffer."]
    pub fn Dart_SetDartLibrarySourcesKernel(
        platform_kernel: *const u8,
        platform_kernel_size: isize,
    );
}
unsafe extern "C" {
    #[doc = " Detect the null safety opt-in status.\n\n When running from source, it is based on the opt-in status of `script_uri`.\n When running from a kernel buffer, it is based on the mode used when\n   generating `kernel_buffer`.\n When running from an appJIT or AOT snapshot, it is based on the mode used\n   when generating `snapshot_data`.\n\n \\param script_uri Uri of the script that contains the source code\n\n \\param package_config Uri of the package configuration file (either in format\n   of .packages or .dart_tool/package_config.json) for the null safety\n   detection to resolve package imports against. If this parameter is not\n   passed the package resolution of the parent isolate should be used.\n\n \\param original_working_directory current working directory when the VM\n   process was launched, this is used to correctly resolve the path specified\n   for package_config.\n\n \\param snapshot_data\n\n \\param snapshot_instructions Buffers containing a snapshot of the\n   isolate or NULL if no snapshot is provided. If provided, the buffers must\n   remain valid until the isolate shuts down.\n\n \\param kernel_buffer\n\n \\param kernel_buffer_size A buffer which contains a kernel/DIL program. Must\n   remain valid until isolate shutdown.\n\n \\return Returns true if the null safety is opted in by the input being\n   run `script_uri`, `snapshot_data` or `kernel_buffer`.\n"]
    pub fn Dart_DetectNullSafety(
        script_uri: *const ::std::os::raw::c_char,
        package_config: *const ::std::os::raw::c_char,
        original_working_directory: *const ::std::os::raw::c_char,
        snapshot_data: *const u8,
        snapshot_instructions: *const u8,
        kernel_buffer: *const u8,
        kernel_buffer_size: isize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns true if isolate is the service isolate.\n\n \\param isolate An isolate\n\n \\return Returns true if 'isolate' is the service isolate."]
    pub fn Dart_IsServiceIsolate(isolate: Dart_Isolate) -> bool;
}
unsafe extern "C" {
    #[doc = " Writes the CPU profile to the timeline as a series of 'instant' events.\n\n Note that this is an expensive operation.\n\n \\param main_port The main port of the Isolate whose profile samples to write.\n \\param error An optional error, must be free()ed by caller.\n\n \\return Returns true if the profile is successfully written and false\n         otherwise."]
    pub fn Dart_WriteProfileToTimeline(
        main_port: Dart_Port,
        error: *mut *mut ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Record all functions which have been compiled in the current isolate.\n\n \\param buffer Returns a pointer to a buffer containing the trace.\n   This buffer is scope allocated and is only valid  until the next call to\n   Dart_ExitScope.\n \\param size Returns the size of the buffer.\n \\return Returns an valid handle upon success."]
    pub fn Dart_SaveCompilationTrace(
        buffer: *mut *mut u8,
        buffer_length: *mut isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Compile all functions from data from Dart_SaveCompilationTrace. Unlike JIT\n feedback, this data is fuzzy: loading does not need to happen in the exact\n program that was saved, the saver and loader do not need to agree on checked\n mode versus production mode or debug/release/product.\n\n \\return Returns an error handle if a compilation error was encountered."]
    pub fn Dart_LoadCompilationTrace(buffer: *mut u8, buffer_length: isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Record runtime feedback for the current isolate, including type feedback\n and usage counters.\n\n \\param buffer Returns a pointer to a buffer containing the trace.\n   This buffer is scope allocated and is only valid  until the next call to\n   Dart_ExitScope.\n \\param size Returns the size of the buffer.\n \\return Returns an valid handle upon success."]
    pub fn Dart_SaveTypeFeedback(buffer: *mut *mut u8, buffer_length: *mut isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Compile functions using data from Dart_SaveTypeFeedback. The data must from a\n VM with the same version and compiler flags.\n\n \\return Returns an error handle if a compilation error was encountered or a\n   version mismatch is detected."]
    pub fn Dart_LoadTypeFeedback(buffer: *mut u8, buffer_length: isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Compiles all functions reachable from entry points and marks\n the isolate to disallow future compilation.\n\n Entry points should be specified using `@pragma(\"vm:entry-point\")`\n annotation.\n\n \\return An error handle if a compilation error or runtime error running const\n constructors was encountered."]
    pub fn Dart_Precompile() -> Dart_Handle;
}
pub type Dart_CreateLoadingUnitCallback = ::std::option::Option<
    unsafe extern "C" fn(
        callback_data: *mut ::std::os::raw::c_void,
        loading_unit_id: isize,
        write_callback_data: *mut *mut ::std::os::raw::c_void,
        write_debug_callback_data: *mut *mut ::std::os::raw::c_void,
    ),
>;
pub type Dart_StreamingWriteCallback = ::std::option::Option<
    unsafe extern "C" fn(
        callback_data: *mut ::std::os::raw::c_void,
        buffer: *const u8,
        size: isize,
    ),
>;
pub type Dart_StreamingCloseCallback =
    ::std::option::Option<unsafe extern "C" fn(callback_data: *mut ::std::os::raw::c_void)>;
unsafe extern "C" {
    pub fn Dart_LoadingUnitLibraryUris(loading_unit_id: isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = "  Creates a precompiled snapshot.\n   - A root library must have been loaded.\n   - Dart_Precompile must have been called.\n\n  Outputs an assembly file defining the symbols listed in the definitions\n  above.\n\n  The assembly should be compiled as a static or shared library and linked or\n  loaded by the embedder. Running this snapshot requires a VM compiled with\n  DART_PRECOMPILED_SNAPSHOT. The kDartVmSnapshotData and\n  kDartVmSnapshotInstructions should be passed to Dart_Initialize. The\n  kDartIsolateSnapshotData and kDartIsolateSnapshotInstructions should be\n  passed to Dart_CreateIsolateGroup.\n\n  The callback will be invoked one or more times to provide the assembly code.\n\n  If stripped is true, then the assembly code will not include DWARF\n  debugging sections.\n\n  If debug_callback_data is provided, debug_callback_data will be used with\n  the callback to provide separate debugging information.\n\n  \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_CreateAppAOTSnapshotAsAssembly(
        callback: Dart_StreamingWriteCallback,
        callback_data: *mut ::std::os::raw::c_void,
        stripped: bool,
        debug_callback_data: *mut ::std::os::raw::c_void,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    pub fn Dart_CreateAppAOTSnapshotAsAssemblies(
        next_callback: Dart_CreateLoadingUnitCallback,
        next_callback_data: *mut ::std::os::raw::c_void,
        stripped: bool,
        write_callback: Dart_StreamingWriteCallback,
        close_callback: Dart_StreamingCloseCallback,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = "  Creates a precompiled snapshot.\n   - A root library must have been loaded.\n   - Dart_Precompile must have been called.\n\n  Outputs an ELF shared library defining the symbols\n   - _kDartVmSnapshotData\n   - _kDartVmSnapshotInstructions\n   - _kDartIsolateSnapshotData\n   - _kDartIsolateSnapshotInstructions\n\n  The shared library should be dynamically loaded by the embedder.\n  Running this snapshot requires a VM compiled with DART_PRECOMPILED_SNAPSHOT.\n  The kDartVmSnapshotData and kDartVmSnapshotInstructions should be passed to\n  Dart_Initialize. The kDartIsolateSnapshotData and\n  kDartIsolateSnapshotInstructions should be passed to Dart_CreateIsolate.\n\n  The callback will be invoked one or more times to provide the binary output.\n\n  If stripped is true, then the binary output will not include DWARF\n  debugging sections.\n\n  If debug_callback_data is provided, debug_callback_data will be used with\n  the callback to provide separate debugging information.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_CreateAppAOTSnapshotAsElf(
        callback: Dart_StreamingWriteCallback,
        callback_data: *mut ::std::os::raw::c_void,
        stripped: bool,
        debug_callback_data: *mut ::std::os::raw::c_void,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    pub fn Dart_CreateAppAOTSnapshotAsElfs(
        next_callback: Dart_CreateLoadingUnitCallback,
        next_callback_data: *mut ::std::os::raw::c_void,
        stripped: bool,
        write_callback: Dart_StreamingWriteCallback,
        close_callback: Dart_StreamingCloseCallback,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = "  Like Dart_CreateAppAOTSnapshotAsAssembly, but only includes\n  kDartVmSnapshotData and kDartVmSnapshotInstructions. It also does\n  not strip DWARF information from the generated assembly or allow for\n  separate debug information."]
    pub fn Dart_CreateVMAOTSnapshotAsAssembly(
        callback: Dart_StreamingWriteCallback,
        callback_data: *mut ::std::os::raw::c_void,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Sorts the class-ids in depth first traversal order of the inheritance\n tree. This is a costly operation, but it can make method dispatch\n more efficient and is done before writing snapshots.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_SortClasses() -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = "  Creates a snapshot that caches compiled code and type feedback for faster\n  startup and quicker warmup in a subsequent process.\n\n  Outputs a snapshot in two pieces. The pieces should be passed to\n  Dart_CreateIsolateGroup in a VM using the same VM snapshot pieces used in the\n  current VM. The instructions piece must be loaded with read and execute\n  permissions; the data piece may be loaded as read-only.\n\n   - Requires the VM to have not been started with --precompilation.\n   - Not supported when targeting IA32.\n   - The VM writing the snapshot and the VM reading the snapshot must be the\n     same version, must be built in the same DEBUG/RELEASE/PRODUCT mode, must\n     be targeting the same architecture, and must both be in checked mode or\n     both in unchecked mode.\n\n  The buffers are scope allocated and are only valid until the next call to\n  Dart_ExitScope.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_CreateAppJITSnapshotAsBlobs(
        isolate_snapshot_data_buffer: *mut *mut u8,
        isolate_snapshot_data_size: *mut isize,
        isolate_snapshot_instructions_buffer: *mut *mut u8,
        isolate_snapshot_instructions_size: *mut isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Like Dart_CreateAppJITSnapshotAsBlobs, but also creates a new VM snapshot."]
    pub fn Dart_CreateCoreJITSnapshotAsBlobs(
        vm_snapshot_data_buffer: *mut *mut u8,
        vm_snapshot_data_size: *mut isize,
        vm_snapshot_instructions_buffer: *mut *mut u8,
        vm_snapshot_instructions_size: *mut isize,
        isolate_snapshot_data_buffer: *mut *mut u8,
        isolate_snapshot_data_size: *mut isize,
        isolate_snapshot_instructions_buffer: *mut *mut u8,
        isolate_snapshot_instructions_size: *mut isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Get obfuscation map for precompiled code.\n\n Obfuscation map is encoded as a JSON array of pairs (original name,\n obfuscated name).\n\n \\return Returns an error handler if the VM was built in a mode that does not\n support obfuscation."]
    pub fn Dart_GetObfuscationMap(buffer: *mut *mut u8, buffer_length: *mut isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = "  Returns whether the VM only supports running from precompiled snapshots and\n  not from any other kind of snapshot or from source (that is, the VM was\n  compiled with DART_PRECOMPILED_RUNTIME)."]
    pub fn Dart_IsPrecompiledRuntime() -> bool;
}
unsafe extern "C" {
    #[doc = "  Print a native stack trace. Used for crash handling.\n\n  If context is NULL, prints the current stack trace. Otherwise, context\n  should be a CONTEXT* (Windows) or ucontext_t* (POSIX) from a signal handler\n  running on the current thread."]
    pub fn Dart_DumpNativeStackTrace(context: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = "  Indicate that the process is about to abort, and the Dart VM should not\n  attempt to cleanup resources."]
    pub fn Dart_PrepareToAbort();
}
pub const Dart_CObject_kNull: Dart_CObject_Type = 0;
pub const Dart_CObject_kBool: Dart_CObject_Type = 1;
pub const Dart_CObject_kInt32: Dart_CObject_Type = 2;
pub const Dart_CObject_kInt64: Dart_CObject_Type = 3;
pub const Dart_CObject_kDouble: Dart_CObject_Type = 4;
pub const Dart_CObject_kString: Dart_CObject_Type = 5;
pub const Dart_CObject_kArray: Dart_CObject_Type = 6;
pub const Dart_CObject_kTypedData: Dart_CObject_Type = 7;
pub const Dart_CObject_kExternalTypedData: Dart_CObject_Type = 8;
pub const Dart_CObject_kSendPort: Dart_CObject_Type = 9;
pub const Dart_CObject_kCapability: Dart_CObject_Type = 10;
pub const Dart_CObject_kUnsupported: Dart_CObject_Type = 11;
pub const Dart_CObject_kNumberOfTypes: Dart_CObject_Type = 12;
#[doc = " A Dart_CObject is used for representing Dart objects as native C\n data outside the Dart heap. These objects are totally detached from\n the Dart heap. Only a subset of the Dart objects have a\n representation as a Dart_CObject.\n\n The string encoding in the 'value.as_string' is UTF-8.\n\n All the different types from dart:typed_data are exposed as type\n kTypedData. The specific type from dart:typed_data is in the type\n field of the as_typed_data structure. The length in the\n as_typed_data structure is always in bytes.\n\n The data for kTypedData is copied on message send and ownership remains with\n the caller. The ownership of data for kExternalTyped is passed to the VM on\n message send and returned when the VM invokes the\n Dart_HandleFinalizer callback; a non-NULL callback must be provided."]
pub type Dart_CObject_Type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _Dart_CObject {
    pub type_: Dart_CObject_Type,
    pub value: _Dart_CObject__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _Dart_CObject__bindgen_ty_1 {
    pub as_bool: bool,
    pub as_int32: i32,
    pub as_int64: i64,
    pub as_double: f64,
    pub as_string: *mut ::std::os::raw::c_char,
    pub as_send_port: _Dart_CObject__bindgen_ty_1__bindgen_ty_1,
    pub as_capability: _Dart_CObject__bindgen_ty_1__bindgen_ty_2,
    pub as_array: _Dart_CObject__bindgen_ty_1__bindgen_ty_3,
    pub as_typed_data: _Dart_CObject__bindgen_ty_1__bindgen_ty_4,
    pub as_external_typed_data: _Dart_CObject__bindgen_ty_1__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_CObject__bindgen_ty_1__bindgen_ty_1 {
    pub id: Dart_Port,
    pub origin_id: Dart_Port,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _Dart_CObject__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<_Dart_CObject__bindgen_ty_1__bindgen_ty_1>() - 16usize];
    ["Alignment of _Dart_CObject__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<_Dart_CObject__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: _Dart_CObject__bindgen_ty_1__bindgen_ty_1::id"]
        [::std::mem::offset_of!(_Dart_CObject__bindgen_ty_1__bindgen_ty_1, id) - 0usize];
    ["Offset of field: _Dart_CObject__bindgen_ty_1__bindgen_ty_1::origin_id"]
        [::std::mem::offset_of!(_Dart_CObject__bindgen_ty_1__bindgen_ty_1, origin_id) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_CObject__bindgen_ty_1__bindgen_ty_2 {
    pub id: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _Dart_CObject__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::size_of::<_Dart_CObject__bindgen_ty_1__bindgen_ty_2>() - 8usize];
    ["Alignment of _Dart_CObject__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::align_of::<_Dart_CObject__bindgen_ty_1__bindgen_ty_2>() - 8usize];
    ["Offset of field: _Dart_CObject__bindgen_ty_1__bindgen_ty_2::id"]
        [::std::mem::offset_of!(_Dart_CObject__bindgen_ty_1__bindgen_ty_2, id) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_CObject__bindgen_ty_1__bindgen_ty_3 {
    pub length: isize,
    pub values: *mut *mut _Dart_CObject,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _Dart_CObject__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::size_of::<_Dart_CObject__bindgen_ty_1__bindgen_ty_3>() - 16usize];
    ["Alignment of _Dart_CObject__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::align_of::<_Dart_CObject__bindgen_ty_1__bindgen_ty_3>() - 8usize];
    ["Offset of field: _Dart_CObject__bindgen_ty_1__bindgen_ty_3::length"]
        [::std::mem::offset_of!(_Dart_CObject__bindgen_ty_1__bindgen_ty_3, length) - 0usize];
    ["Offset of field: _Dart_CObject__bindgen_ty_1__bindgen_ty_3::values"]
        [::std::mem::offset_of!(_Dart_CObject__bindgen_ty_1__bindgen_ty_3, values) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_CObject__bindgen_ty_1__bindgen_ty_4 {
    pub type_: Dart_TypedData_Type,
    pub length: isize,
    pub values: *mut u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _Dart_CObject__bindgen_ty_1__bindgen_ty_4"]
        [::std::mem::size_of::<_Dart_CObject__bindgen_ty_1__bindgen_ty_4>() - 24usize];
    ["Alignment of _Dart_CObject__bindgen_ty_1__bindgen_ty_4"]
        [::std::mem::align_of::<_Dart_CObject__bindgen_ty_1__bindgen_ty_4>() - 8usize];
    ["Offset of field: _Dart_CObject__bindgen_ty_1__bindgen_ty_4::type_"]
        [::std::mem::offset_of!(_Dart_CObject__bindgen_ty_1__bindgen_ty_4, type_) - 0usize];
    ["Offset of field: _Dart_CObject__bindgen_ty_1__bindgen_ty_4::length"]
        [::std::mem::offset_of!(_Dart_CObject__bindgen_ty_1__bindgen_ty_4, length) - 8usize];
    ["Offset of field: _Dart_CObject__bindgen_ty_1__bindgen_ty_4::values"]
        [::std::mem::offset_of!(_Dart_CObject__bindgen_ty_1__bindgen_ty_4, values) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_CObject__bindgen_ty_1__bindgen_ty_5 {
    pub type_: Dart_TypedData_Type,
    pub length: isize,
    pub data: *mut u8,
    pub peer: *mut ::std::os::raw::c_void,
    pub callback: Dart_HandleFinalizer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _Dart_CObject__bindgen_ty_1__bindgen_ty_5"]
        [::std::mem::size_of::<_Dart_CObject__bindgen_ty_1__bindgen_ty_5>() - 40usize];
    ["Alignment of _Dart_CObject__bindgen_ty_1__bindgen_ty_5"]
        [::std::mem::align_of::<_Dart_CObject__bindgen_ty_1__bindgen_ty_5>() - 8usize];
    ["Offset of field: _Dart_CObject__bindgen_ty_1__bindgen_ty_5::type_"]
        [::std::mem::offset_of!(_Dart_CObject__bindgen_ty_1__bindgen_ty_5, type_) - 0usize];
    ["Offset of field: _Dart_CObject__bindgen_ty_1__bindgen_ty_5::length"]
        [::std::mem::offset_of!(_Dart_CObject__bindgen_ty_1__bindgen_ty_5, length) - 8usize];
    ["Offset of field: _Dart_CObject__bindgen_ty_1__bindgen_ty_5::data"]
        [::std::mem::offset_of!(_Dart_CObject__bindgen_ty_1__bindgen_ty_5, data) - 16usize];
    ["Offset of field: _Dart_CObject__bindgen_ty_1__bindgen_ty_5::peer"]
        [::std::mem::offset_of!(_Dart_CObject__bindgen_ty_1__bindgen_ty_5, peer) - 24usize];
    ["Offset of field: _Dart_CObject__bindgen_ty_1__bindgen_ty_5::callback"]
        [::std::mem::offset_of!(_Dart_CObject__bindgen_ty_1__bindgen_ty_5, callback) - 32usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _Dart_CObject__bindgen_ty_1"]
        [::std::mem::size_of::<_Dart_CObject__bindgen_ty_1>() - 40usize];
    ["Alignment of _Dart_CObject__bindgen_ty_1"]
        [::std::mem::align_of::<_Dart_CObject__bindgen_ty_1>() - 8usize];
    ["Offset of field: _Dart_CObject__bindgen_ty_1::as_bool"]
        [::std::mem::offset_of!(_Dart_CObject__bindgen_ty_1, as_bool) - 0usize];
    ["Offset of field: _Dart_CObject__bindgen_ty_1::as_int32"]
        [::std::mem::offset_of!(_Dart_CObject__bindgen_ty_1, as_int32) - 0usize];
    ["Offset of field: _Dart_CObject__bindgen_ty_1::as_int64"]
        [::std::mem::offset_of!(_Dart_CObject__bindgen_ty_1, as_int64) - 0usize];
    ["Offset of field: _Dart_CObject__bindgen_ty_1::as_double"]
        [::std::mem::offset_of!(_Dart_CObject__bindgen_ty_1, as_double) - 0usize];
    ["Offset of field: _Dart_CObject__bindgen_ty_1::as_string"]
        [::std::mem::offset_of!(_Dart_CObject__bindgen_ty_1, as_string) - 0usize];
    ["Offset of field: _Dart_CObject__bindgen_ty_1::as_send_port"]
        [::std::mem::offset_of!(_Dart_CObject__bindgen_ty_1, as_send_port) - 0usize];
    ["Offset of field: _Dart_CObject__bindgen_ty_1::as_capability"]
        [::std::mem::offset_of!(_Dart_CObject__bindgen_ty_1, as_capability) - 0usize];
    ["Offset of field: _Dart_CObject__bindgen_ty_1::as_array"]
        [::std::mem::offset_of!(_Dart_CObject__bindgen_ty_1, as_array) - 0usize];
    ["Offset of field: _Dart_CObject__bindgen_ty_1::as_typed_data"]
        [::std::mem::offset_of!(_Dart_CObject__bindgen_ty_1, as_typed_data) - 0usize];
    ["Offset of field: _Dart_CObject__bindgen_ty_1::as_external_typed_data"]
        [::std::mem::offset_of!(_Dart_CObject__bindgen_ty_1, as_external_typed_data) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _Dart_CObject"][::std::mem::size_of::<_Dart_CObject>() - 48usize];
    ["Alignment of _Dart_CObject"][::std::mem::align_of::<_Dart_CObject>() - 8usize];
    ["Offset of field: _Dart_CObject::type_"]
        [::std::mem::offset_of!(_Dart_CObject, type_) - 0usize];
    ["Offset of field: _Dart_CObject::value"]
        [::std::mem::offset_of!(_Dart_CObject, value) - 8usize];
};
pub type Dart_CObject = _Dart_CObject;
unsafe extern "C" {
    #[doc = " Posts a message on some port. The message will contain the Dart_CObject\n object graph rooted in 'message'.\n\n While the message is being sent the state of the graph of Dart_CObject\n structures rooted in 'message' should not be accessed, as the message\n generation will make temporary modifications to the data. When the message\n has been sent the graph will be fully restored.\n\n If true is returned, the message was enqueued, and finalizers for external\n typed data will eventually run, even if the receiving isolate shuts down\n before processing the message. If false is returned, the message was not\n enqueued and ownership of external typed data in the message remains with the\n caller.\n\n This function may be called on any thread when the VM is running (that is,\n after Dart_Initialize has returned and before Dart_Cleanup has been called).\n\n \\param port_id The destination port.\n \\param message The message to send.\n\n \\return True if the message was posted."]
    pub fn Dart_PostCObject(port_id: Dart_Port, message: *mut Dart_CObject) -> bool;
}
unsafe extern "C" {
    #[doc = " Posts a message on some port. The message will contain the integer 'message'.\n\n \\param port_id The destination port.\n \\param message The message to send.\n\n \\return True if the message was posted."]
    pub fn Dart_PostInteger(port_id: Dart_Port, message: i64) -> bool;
}
#[doc = " A native message handler.\n\n This handler is associated with a native port by calling\n Dart_NewNativePort.\n\n The message received is decoded into the message structure. The\n lifetime of the message data is controlled by the caller. All the\n data references from the message are allocated by the caller and\n will be reclaimed when returning to it."]
pub type Dart_NativeMessageHandler = ::std::option::Option<
    unsafe extern "C" fn(dest_port_id: Dart_Port, message: *mut Dart_CObject),
>;
unsafe extern "C" {
    #[doc = " Creates a new native port.  When messages are received on this\n native port, then they will be dispatched to the provided native\n message handler.\n\n \\param name The name of this port in debugging messages.\n \\param handler The C handler to run when messages arrive on the port.\n \\param handle_concurrently Is it okay to process requests on this\n                            native port concurrently?\n\n \\return If successful, returns the port id for the native port.  In\n   case of error, returns ILLEGAL_PORT."]
    pub fn Dart_NewNativePort(
        name: *const ::std::os::raw::c_char,
        handler: Dart_NativeMessageHandler,
        handle_concurrently: bool,
    ) -> Dart_Port;
}
unsafe extern "C" {
    #[doc = " Closes the native port with the given id.\n\n The port must have been allocated by a call to Dart_NewNativePort.\n\n \\param native_port_id The id of the native port to close.\n\n \\return Returns true if the port was closed successfully."]
    pub fn Dart_CloseNativePort(native_port_id: Dart_Port) -> bool;
}
unsafe extern "C" {
    #[doc = " Forces all loaded classes and functions to be compiled eagerly in\n the current isolate..\n\n TODO(turnidge): Document."]
    pub fn Dart_CompileAll() -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Finalizes all classes."]
    pub fn Dart_FinalizeAllClasses() -> Dart_Handle;
}
unsafe extern "C" {
    pub fn Dart_ExecuteInternalCommand(
        command: *const ::std::os::raw::c_char,
        arg: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn Dart_InitializeApiDL(data: *mut ::std::os::raw::c_void) -> isize;
}
pub type Dart_Port_DL = i64;
pub type Dart_NativeMessageHandler_DL = ::std::option::Option<
    unsafe extern "C" fn(dest_port_id: Dart_Port_DL, message: *mut Dart_CObject),
>;
pub type Dart_PostCObject_Type = ::std::option::Option<
    unsafe extern "C" fn(port_id: Dart_Port_DL, message: *mut Dart_CObject) -> bool,
>;
unsafe extern "C" {
    pub static mut Dart_PostCObject_DL: Dart_PostCObject_Type;
}
pub type Dart_PostInteger_Type =
    ::std::option::Option<unsafe extern "C" fn(port_id: Dart_Port_DL, message: i64) -> bool>;
unsafe extern "C" {
    pub static mut Dart_PostInteger_DL: Dart_PostInteger_Type;
}
pub type Dart_NewNativePort_Type = ::std::option::Option<
    unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
        handler: Dart_NativeMessageHandler_DL,
        handle_concurrently: bool,
    ) -> Dart_Port_DL,
>;
unsafe extern "C" {
    pub static mut Dart_NewNativePort_DL: Dart_NewNativePort_Type;
}
pub type Dart_CloseNativePort_Type =
    ::std::option::Option<unsafe extern "C" fn(native_port_id: Dart_Port_DL) -> bool>;
unsafe extern "C" {
    pub static mut Dart_CloseNativePort_DL: Dart_CloseNativePort_Type;
}
pub type Dart_IsError_Type =
    ::std::option::Option<unsafe extern "C" fn(handle: Dart_Handle) -> bool>;
unsafe extern "C" {
    pub static mut Dart_IsError_DL: Dart_IsError_Type;
}
pub type Dart_IsApiError_Type =
    ::std::option::Option<unsafe extern "C" fn(handle: Dart_Handle) -> bool>;
unsafe extern "C" {
    pub static mut Dart_IsApiError_DL: Dart_IsApiError_Type;
}
pub type Dart_IsUnhandledExceptionError_Type =
    ::std::option::Option<unsafe extern "C" fn(handle: Dart_Handle) -> bool>;
unsafe extern "C" {
    pub static mut Dart_IsUnhandledExceptionError_DL: Dart_IsUnhandledExceptionError_Type;
}
pub type Dart_IsCompilationError_Type =
    ::std::option::Option<unsafe extern "C" fn(handle: Dart_Handle) -> bool>;
unsafe extern "C" {
    pub static mut Dart_IsCompilationError_DL: Dart_IsCompilationError_Type;
}
pub type Dart_IsFatalError_Type =
    ::std::option::Option<unsafe extern "C" fn(handle: Dart_Handle) -> bool>;
unsafe extern "C" {
    pub static mut Dart_IsFatalError_DL: Dart_IsFatalError_Type;
}
pub type Dart_GetError_Type = ::std::option::Option<
    unsafe extern "C" fn(handle: Dart_Handle) -> *const ::std::os::raw::c_char,
>;
unsafe extern "C" {
    pub static mut Dart_GetError_DL: Dart_GetError_Type;
}
pub type Dart_ErrorHasException_Type =
    ::std::option::Option<unsafe extern "C" fn(handle: Dart_Handle) -> bool>;
unsafe extern "C" {
    pub static mut Dart_ErrorHasException_DL: Dart_ErrorHasException_Type;
}
pub type Dart_ErrorGetException_Type =
    ::std::option::Option<unsafe extern "C" fn(handle: Dart_Handle) -> Dart_Handle>;
unsafe extern "C" {
    pub static mut Dart_ErrorGetException_DL: Dart_ErrorGetException_Type;
}
pub type Dart_ErrorGetStackTrace_Type =
    ::std::option::Option<unsafe extern "C" fn(handle: Dart_Handle) -> Dart_Handle>;
unsafe extern "C" {
    pub static mut Dart_ErrorGetStackTrace_DL: Dart_ErrorGetStackTrace_Type;
}
pub type Dart_NewApiError_Type = ::std::option::Option<
    unsafe extern "C" fn(error: *const ::std::os::raw::c_char) -> Dart_Handle,
>;
unsafe extern "C" {
    pub static mut Dart_NewApiError_DL: Dart_NewApiError_Type;
}
pub type Dart_NewCompilationError_Type = ::std::option::Option<
    unsafe extern "C" fn(error: *const ::std::os::raw::c_char) -> Dart_Handle,
>;
unsafe extern "C" {
    pub static mut Dart_NewCompilationError_DL: Dart_NewCompilationError_Type;
}
pub type Dart_NewUnhandledExceptionError_Type =
    ::std::option::Option<unsafe extern "C" fn(exception: Dart_Handle) -> Dart_Handle>;
unsafe extern "C" {
    pub static mut Dart_NewUnhandledExceptionError_DL: Dart_NewUnhandledExceptionError_Type;
}
pub type Dart_PropagateError_Type =
    ::std::option::Option<unsafe extern "C" fn(handle: Dart_Handle)>;
unsafe extern "C" {
    pub static mut Dart_PropagateError_DL: Dart_PropagateError_Type;
}
pub type Dart_HandleFromPersistent_Type =
    ::std::option::Option<unsafe extern "C" fn(object: Dart_PersistentHandle) -> Dart_Handle>;
unsafe extern "C" {
    pub static mut Dart_HandleFromPersistent_DL: Dart_HandleFromPersistent_Type;
}
pub type Dart_HandleFromWeakPersistent_Type =
    ::std::option::Option<unsafe extern "C" fn(object: Dart_WeakPersistentHandle) -> Dart_Handle>;
unsafe extern "C" {
    pub static mut Dart_HandleFromWeakPersistent_DL: Dart_HandleFromWeakPersistent_Type;
}
pub type Dart_NewPersistentHandle_Type =
    ::std::option::Option<unsafe extern "C" fn(object: Dart_Handle) -> Dart_PersistentHandle>;
unsafe extern "C" {
    pub static mut Dart_NewPersistentHandle_DL: Dart_NewPersistentHandle_Type;
}
pub type Dart_SetPersistentHandle_Type =
    ::std::option::Option<unsafe extern "C" fn(obj1: Dart_PersistentHandle, obj2: Dart_Handle)>;
unsafe extern "C" {
    pub static mut Dart_SetPersistentHandle_DL: Dart_SetPersistentHandle_Type;
}
pub type Dart_DeletePersistentHandle_Type =
    ::std::option::Option<unsafe extern "C" fn(object: Dart_PersistentHandle)>;
unsafe extern "C" {
    pub static mut Dart_DeletePersistentHandle_DL: Dart_DeletePersistentHandle_Type;
}
pub type Dart_NewWeakPersistentHandle_Type = ::std::option::Option<
    unsafe extern "C" fn(
        object: Dart_Handle,
        peer: *mut ::std::os::raw::c_void,
        external_allocation_size: isize,
        callback: Dart_HandleFinalizer,
    ) -> Dart_WeakPersistentHandle,
>;
unsafe extern "C" {
    pub static mut Dart_NewWeakPersistentHandle_DL: Dart_NewWeakPersistentHandle_Type;
}
pub type Dart_DeleteWeakPersistentHandle_Type =
    ::std::option::Option<unsafe extern "C" fn(object: Dart_WeakPersistentHandle)>;
unsafe extern "C" {
    pub static mut Dart_DeleteWeakPersistentHandle_DL: Dart_DeleteWeakPersistentHandle_Type;
}
pub type Dart_UpdateExternalSize_Type = ::std::option::Option<
    unsafe extern "C" fn(object: Dart_WeakPersistentHandle, external_allocation_size: isize),
>;
unsafe extern "C" {
    pub static mut Dart_UpdateExternalSize_DL: Dart_UpdateExternalSize_Type;
}
pub type Dart_NewFinalizableHandle_Type = ::std::option::Option<
    unsafe extern "C" fn(
        object: Dart_Handle,
        peer: *mut ::std::os::raw::c_void,
        external_allocation_size: isize,
        callback: Dart_HandleFinalizer,
    ) -> Dart_FinalizableHandle,
>;
unsafe extern "C" {
    pub static mut Dart_NewFinalizableHandle_DL: Dart_NewFinalizableHandle_Type;
}
pub type Dart_DeleteFinalizableHandle_Type = ::std::option::Option<
    unsafe extern "C" fn(object: Dart_FinalizableHandle, strong_ref_to_object: Dart_Handle),
>;
unsafe extern "C" {
    pub static mut Dart_DeleteFinalizableHandle_DL: Dart_DeleteFinalizableHandle_Type;
}
pub type Dart_UpdateFinalizableExternalSize_Type = ::std::option::Option<
    unsafe extern "C" fn(
        object: Dart_FinalizableHandle,
        strong_ref_to_object: Dart_Handle,
        external_allocation_size: isize,
    ),
>;
unsafe extern "C" {
    pub static mut Dart_UpdateFinalizableExternalSize_DL: Dart_UpdateFinalizableExternalSize_Type;
}
pub type Dart_Post_Type =
    ::std::option::Option<unsafe extern "C" fn(port_id: Dart_Port_DL, object: Dart_Handle) -> bool>;
unsafe extern "C" {
    pub static mut Dart_Post_DL: Dart_Post_Type;
}
pub type Dart_NewSendPort_Type =
    ::std::option::Option<unsafe extern "C" fn(port_id: Dart_Port_DL) -> Dart_Handle>;
unsafe extern "C" {
    pub static mut Dart_NewSendPort_DL: Dart_NewSendPort_Type;
}
pub type Dart_SendPortGetId_Type = ::std::option::Option<
    unsafe extern "C" fn(port: Dart_Handle, port_id: *mut Dart_Port_DL) -> Dart_Handle,
>;
unsafe extern "C" {
    pub static mut Dart_SendPortGetId_DL: Dart_SendPortGetId_Type;
}
pub type Dart_EnterScope_Type = ::std::option::Option<unsafe extern "C" fn()>;
unsafe extern "C" {
    pub static mut Dart_EnterScope_DL: Dart_EnterScope_Type;
}
pub type Dart_ExitScope_Type = ::std::option::Option<unsafe extern "C" fn()>;
unsafe extern "C" {
    pub static mut Dart_ExitScope_DL: Dart_ExitScope_Type;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
